# -*- coding: utf-8 -*-
"""TGDK-2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p8lEpTqehrRwrN98TvWNvMOkJvKSXQZO
"""

from __future__ import annotations

import heapq
import numpy as np
import pandas as pd
from typing import Dict, Tuple, List, Optional
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection

# ------------------------------
# Event types
# ------------------------------
BUYER_COMPUTE = 1
POST_BID = 2

# ------------------------------
# Market construction
# ------------------------------

def make_market_multi(I: int,
                      J: int,
                      Q_max: float | np.ndarray = 100.0,
                      epsilon: float = 5.0,
                      reserve: float | np.ndarray = 0.0,
                      budget_range=(1000.0, 1000.0),
                      q_range=(10.0, 60.0),
                      kappa_range=(1.0, 3.5),
                      seed: int = 12345,
                      jitter: float = 0.01,
                      price_tol: float = 5e-3,
                      adj: Optional[np.ndarray] = None) -> Dict:
    """Create a multi-seller PSP market state as flat arrays.

    Buyer arrays (len I): b, qbar, kappa, gen
    Seller arrays (len J): Q_max, reserve
    Bid arrays (I×J): bid_q, bid_p
    """
    rng = np.random.default_rng(seed)
    b = rng.uniform(*budget_range, size=I)
    qbar = rng.uniform(*q_range, size=I)
    kappa = rng.uniform(*kappa_range, size=I)

    Q_max = np.full(J, float(Q_max)) if np.isscalar(Q_max) else np.asarray(Q_max, dtype=float)
    assert Q_max.shape == (J,)
    reserve = np.full(J, float(reserve)) if np.isscalar(reserve) else np.asarray(reserve, dtype=float)
    assert reserve.shape == (J,)

    bid_q = np.zeros((I, J), dtype=float)
    bid_p = np.zeros((I, J), dtype=float)

    M = {
        "I": I,
        "J": J,
        "b": np.ascontiguousarray(b, dtype=float),
        "qbar": np.ascontiguousarray(qbar, dtype=float),
        "kappa": np.ascontiguousarray(kappa, dtype=float),
        "Q_max": np.ascontiguousarray(Q_max, dtype=float),
        "reserve": np.ascontiguousarray(reserve, dtype=float),
        "bid_q": np.ascontiguousarray(bid_q, dtype=float),
        "bid_p": np.ascontiguousarray(bid_p, dtype=float),
        "adj": np.ascontiguousarray(adj, dtype=bool),
        "epsilon": float(epsilon),
        # async engine
        "pq": [],
        "seq": 0,
        "t": 0.0,
        "jitter": float(jitter),
        "rng": rng,
        # buyer generations (staleness guard for POST_BID)
        "gen": np.zeros(I, dtype=np.int64),
        # tolerances
        "tol": 1e-12,
        # convergence bookkeeping
        "pending_posts": 0,
        "events_since_apply": 0,
        "price_tol": float(price_tol),
        "seller_converged": np.ones(J, dtype=bool),
    }

    return M

# ------------------------------
# Buyer valuation and derivatives
# ------------------------------

def theta_i(i: int, z: float, M: Dict) -> float:
    """θ_i(z) = κ_i * qbar_i * m − 0.5 * κ_i * m^2, with m = min(z, qbar_i)."""
    m = min(z, float(M["qbar"][i]))
    k = float(M["kappa"][i])
    return k * float(M["qbar"][i]) * m - 0.5 * k * m * m


def theta_i_prime(i: int, z: float, M: Dict) -> float:
    """θ'_i(z) = κ_i * (qbar_i − z) for z ≤ qbar_i; 0 beyond."""
    q = float(M["qbar"][i])
    k = float(M["kappa"][i])
    return k * (q - z) if z < q else 0.0

# ------------------------------
# Seller-side primitives (columnwise)
# ------------------------------

def _others_mask(i: int, I: int) -> np.ndarray:
    m = np.ones(I, dtype=bool); m[i] = False; return m


def Q_i_j(i: int, j: int, p: float, M: Dict) -> float:
    """Q_i^j(p): remaining capacity at seller j after removing opponents with price > p."""
    mask = _others_mask(i, M["I"]) ; qcol = M["bid_q"][mask, j] ; pcol = M["bid_p"][mask, j]
    rem = M["Q_max"][j] - float(np.sum(qcol[pcol > p]))
    return rem if rem > 0.0 else 0.0


def Qbar_i_j(i: int, j: int, p: float, M: Dict) -> float:
    """Q̄_i^j(p): remaining capacity at seller j after removing opponents with price ≥ p."""
    mask = _others_mask(i, M["I"]) ; qcol = M["bid_q"][mask, j] ; pcol = M["bid_p"][mask, j]
    rem = M["Q_max"][j] - float(np.sum(qcol[pcol >= p]))
    return rem if rem > 0.0 else 0.0


def P_i_j(i: int, j: int, z: float, M: Dict) -> float:
    """Price density P_i^j(z) = inf{ y ≥ 0 : Q_i^j(y) ≥ z }. Evaluate across candidate prices."""
    others = _others_mask(i, M["I"]) ; cand = np.unique(np.concatenate(([0.0], M["bid_p"][others, j])))
    for y in cand:
        if Q_i_j(i, j, float(y), M) >= z:
            return float(y)
    return float("inf")


def integral_P_i_j(i: int, j: int, a: float, M: Dict, N: int = 100) -> float:
    if a <= 0.0: return 0.0
    zs = np.linspace(0.0, a, N + 1)
    Ps = np.array([P_i_j(i, j, float(zk), M) for zk in zs])
    dz = a / N
    return float(np.trapezoid(Ps, dx=dz))

# ------------------------------
# Current allocation/cost/utility for buyer i (snapshot based)
# ------------------------------

def a_row(i: int, M: Dict) -> Tuple[np.ndarray, float]:
    """Return per-seller allocations a_ij for current bids, and their total."""
    J = M["J"]
    a = np.zeros(J, dtype=float)
    for j in range(J):
        q, p = float(M["bid_q"][i, j]), float(M["bid_p"][i, j])
        a[j] = min(q, Qbar_i_j(i, j, p, M))
    return a, float(np.sum(a))

def cost_row(i: int, a: np.ndarray, M: Dict) -> float:
    J = M["J"]; return float(sum(integral_P_i_j(i, j, float(a[j]), M) for j in range(J)))

def u_i_current(i: int, M: Dict) -> float:
    a, atot = a_row(i, M)
    cost = cost_row(i, a, M)
    return theta_i(i, atot, M) - cost

# ------------------------------
# Joint best response
# ------------------------------

def build_ladders(i: int, M: Dict) -> Dict:
    """
    Build per-seller price ladders of opponents for buyer i:
      - per_seller[j]: dict with fields
          'p'    : opponents' posted prices at seller j (ascending, filtered by adjacency)
          'q'    : aligned opponents' quantities
          'pref' : prefix sums of q (pref[t] = sum_{<t} q_sorted)
          'suf'  : suffix sums of q (suf[t]  = sum_{>=t} q_sorted)
      - steps: sorted global union of {0} ∪ {opponent prices across all sellers} ∪ {w_max}
      - w_max: θ'_i(0)
    """
    I, J = int(M["I"]), int(M["J"])
    others = np.ones(I, dtype=bool); others[i] = False
    has_adj = M.get("adj") is not None

    per_seller = []
    all_steps = [0.0]
    for j in range(J):
        if has_adj:
            opp_ok = M["adj"][others, j]
        else:
            opp_ok = np.ones(I - 1, dtype=bool)
        pcol = np.asarray(M["bid_p"][others, j][opp_ok], dtype=float)
        qcol = np.asarray(M["bid_q"][others, j][opp_ok], dtype=float)
        if pcol.size:
            idx = np.argsort(pcol, kind="mergesort")
            p_sorted = pcol[idx]
            q_sorted = qcol[idx]
            n = p_sorted.size
            pref = np.empty(n + 1, dtype=float); pref[0] = 0.0
            for t in range(n): pref[t + 1] = pref[t] + float(q_sorted[t])
            suf  = np.empty(n + 1, dtype=float); suf[n] = 0.0
            for t in range(n - 1, -1, -1): suf[t] = suf[t + 1] + float(q_sorted[t])
            per_seller.append({"p": p_sorted, "q": q_sorted, "pref": pref, "suf": suf})
            all_steps.extend(np.unique(p_sorted).tolist())
        else:
            per_seller.append({"p": np.array([], float),
                               "q": np.array([], float),
                               "pref": np.array([0.0], float),
                               "suf":  np.array([0.0], float)})
    w_max = float(theta_i_prime(i, 0.0, M))
    steps = np.unique(np.concatenate([np.asarray(all_steps, float), np.array([w_max], float)]))
    return {"per_seller": per_seller, "steps": steps, "w_max": w_max}

def _rem_gt_at(i: int, j: int, y: float, M: Dict, ladders: Dict) -> float:
    """
    Remaining capacity at seller j after removing opponents with price > y (strict '>').
    O(log I) using the ladder. Respects adjacency (i,j).
    """
    if M.get("adj") is not None and not bool(M["adj"][i, j]):
        return 0.0
    L = ladders["per_seller"][j]; p_sorted, suf = L["p"], L["suf"]
    if p_sorted.size == 0:
        return float(M["Q_max"][j])
    idx = int(np.searchsorted(p_sorted, float(y), side="right"))
    taken = float(suf[idx])
    rem = float(M["Q_max"][j]) - taken
    return rem if rem > 0.0 else 0.0

def _equals_mass_at(j: int, y: float, ladders: Dict) -> float:
    """
    Total opponents' quantity at seller j with price exactly y.
    """
    L = ladders["per_seller"][j]; p_sorted, pref = L["p"], L["pref"]
    if p_sorted.size == 0:
        return 0.0
    left  = int(np.searchsorted(p_sorted, float(y), side="left"))
    right = int(np.searchsorted(p_sorted, float(y), side="right"))
    return float(pref[right] - pref[left])

def _equals_count_at(j: int, y: float, ladders: Dict) -> int:
    """
    Number of opponents at seller j with price exactly y (for count-based QJC).
    """
    L = ladders["per_seller"][j]; p_sorted = L["p"]
    if p_sorted.size == 0:
        return 0
    left  = int(np.searchsorted(p_sorted, float(y), side="left"))
    right = int(np.searchsorted(p_sorted, float(y), side="right"))
    return int(max(0, right - left))

def seller_caps_at(i: int, y: float, M: Dict, ladders: Dict) -> np.ndarray:
    """
    Caps z_caps[j] available to buyer i at price boundary yy under a tie policy,
        split residual among equals by COUNT (approx QJC)
    """
    J = int(M["J"]); caps = np.zeros(J, dtype=float)
    for j in range(J):
        rem = _rem_gt_at(i, j, y, M, ladders)
        # Split residual among equal-price group (opponents at y plus buyer i)
        eq_cnt = 1 + _equals_count_at(j, y, ladders)
        caps[j] = (rem / float(eq_cnt)) if rem > 0.0 else 0.0
        # We cannot determine a quantity-proportional cap without q_ij.
        # Return the open cap; we'll enforce QJC proportionally after we pick q_row.
        #caps[j] = rem
    return caps

def sup_G_i_multi(i: int, M: Dict, ladders: Dict
                  ) -> Tuple[float, np.ndarray, float, Dict]:
    """
    Stepwise selection of w*: scan open intervals (y_k, y_{k+1}) for interior fixed point.
    If none, choose a boundary according to Jia Caine
    Returns: w_star, caps, z_star, meta  (meta = {'type': 'interior'|'boundary', 'y': y_star})
    """
    tol = float(M["tol"])
    steps = ladders["steps"]; w_max = float(ladders["w_max"])

    # 1) Try to find interior solution
    for k in range(steps.size - 1):
        yk, yk1 = float(steps[k]), float(steps[k + 1])
        if yk1 <= yk + tol:
            continue
        # availability is constant on (yk, yk1): evaluate at left boundary with strict '>'
        z_caps = seller_caps_at(i, yk, M, ladders)
        Z = float(np.sum(z_caps))
        w_imp = float(theta_i_prime(i, Z, M))
        if (w_imp > yk + tol) and (w_imp < yk1 - tol):
            z_star = min(float(M["qbar"][i]), Z)
            return w_imp, z_caps, z_star, {"type": "interior", "y": None}

    # 2) No interior: compute f(y_k) = θ'(Z_k) - y_k at each left boundary and locate crossing
    f_vals = []
    for k in range(steps.size - 1):  # exclude last boundary as a left boundary
        yk = float(steps[k])
        z_caps = seller_caps_at(i, yk, M, ladders)
        Zk = float(np.sum(z_caps))
        f_vals.append(float(theta_i_prime(i, Zk, M) - yk))

    # If degenerate (no opponents), take y*=0 as "lower"
    if len(f_vals) == 0:
        k_star = 0
    else:
        k_star = max([idx for idx, fv in enumerate(f_vals) if fv >= -tol], default=0)

    y_lower = float(steps[k_star])
    y_upper = float(steps[min(k_star + 1, steps.size - 1)])  # right boundary of that interval

    # Helper to build a *complete* plan at a boundary and return (w, caps, z_star, q_row, p_row, cost, u, feasible, meta)
    def eval_boundary(which: str):
        if which == "lower":
            w = y_lower
            caps = seller_caps_at(i, y_lower, M, ladders)
            meta = {"type": "boundary", "y": y_lower}
        elif which == "upper":
            # choose w just below the upper boundary; caps from open interval at y_lower
            w = max(y_upper - tol, 0.0)
            caps = seller_caps_at(i, y_lower, M, ladders)
            meta = {"type": "boundary", "y": y_upper}
        else:
            raise ValueError(which)

        z_star = min(float(M["qbar"][i]), float(np.sum(caps)))
        q_row, p_row, cost, u_new, feasible = compute_t_i_multi(
            i, M, w, caps, z_star, meta
        )
        return w, caps, z_star, q_row, p_row, cost, u_new, feasible, meta
    endpoint_policy = "upper"
    ep = str(endpoint_policy).lower()
    # legacy endpoint behaviors
    if ep == "upper":
        w_star = max(y_upper - tol, 0.0)
        caps   = seller_caps_at(i, y_lower, M, ladders)
        z_star = min(float(M["qbar"][i]), float(np.sum(caps)))
        return w_star, caps, z_star, {"type": "boundary", "y": y_upper}
    elif ep in ("lower", "qjc"):
        w_star = y_lower
        caps   = seller_caps_at(i, y_lower, M, ladders)
        z_star = min(float(M["qbar"][i]), float(np.sum(caps)))
        return w_star, caps, z_star, {"type": "boundary", "y": y_lower}
    else:
        # default to lower
        w_star = y_lower
        caps   = seller_caps_at(i, y_lower, M, ladders)
        z_star = min(float(M["qbar"][i]), float(np.sum(caps)))
        return w_star, caps, z_star, {"type": "boundary", "y": y_lower}

def _min_cost_split(i: int, M: Dict, z_star: float, caps: np.ndarray, ladders: Dict, y_ref: float) -> np.ndarray:
    """
    Utility-max split: choose q_row to minimize PSP cost subject to sum q = z_star and 0 ≤ q ≤ caps.
    Construct per-seller (price, length) segments up to y_ref, merge globally, and take the cheapest units first.
    """
    J = int(M["J"])
    q_row = np.zeros(J, dtype=float)
    if z_star <= 0.0:
        return q_row

    segments: List[Tuple[float, float, int]] = []
    for j in range(J):
        if caps[j] > 1e-15:
            segments.extend(_per_seller_segments_upto(i, j, float(y_ref), M, ladders))

    # Sort by price ascending (stable)
    segments.sort(key=lambda t: t[0])

    rem = float(z_star)
    for price, length, j in segments:
        if rem <= 1e-15:
            break
        room = float(caps[j]) - float(q_row[j])
        if room <= 1e-15:
            continue
        take = min(rem, room, float(length))
        if take > 0.0:
            q_row[j] += take
            rem -= take

    # Numerical clip
    q_row = np.minimum(q_row, caps)
    return q_row

def _per_seller_segments_upto(i: int, j: int, y_ref: float, M: Dict, ladders: Dict) -> List[Tuple[float, float, int]]:
    """
    Return price segments for seller j up to boundary y_ref as a list of
      (price_level, segment_length, j).
    Segment at price y_t represents the additional capacity unlocked exactly at y_t.
    Includes the y=0 segment if any capacity is available at 0.
    Respects adjacency (i,j).
    """
    if M.get("adj") is not None and not bool(M["adj"][i, j]):
        return []

    L = ladders["per_seller"][j]
    p_sorted = L["p"]

    # All local step prices up to y_ref (inclusive), plus 0
    if p_sorted.size:
        steps_j = np.unique(np.concatenate(([0.0], p_sorted[p_sorted <= float(y_ref)])))
    else:
        steps_j = np.array([0.0], dtype=float)

    segs: List[Tuple[float, float, int]] = []
    prev_rem = 0.0
    for y in steps_j:
        rem = _rem_gt_at(i, j, float(y), M, ladders)   # remaining capacity with strict '>'
        delta = rem - prev_rem
        if delta > 1e-15:
            # Units first available at price y get priced at y
            segs.append((float(y), float(delta), int(j)))
        prev_rem = rem
    return segs

def apply_budget_policy(i: int, M: Dict, q_row: np.ndarray, base_cost: float
                         ) -> Tuple[np.ndarray, float, float, bool]:
    """
    Returns (q_row_new, cost_new, u_new, feasible).
        if cost>b_i, reject
    """
    b_i = float(M["b"][i])
    Z0 = float(np.sum(q_row))

    def util_from(qv: np.ndarray, c: float) -> float:
        return theta_i(i, float(np.sum(qv)), M) - float(c)

    # Accept if already within budget (small tolerance)
    if base_cost <= b_i + 1e-9:
        return q_row, base_cost, util_from(q_row, base_cost), True

    return q_row, base_cost, util_from(q_row, base_cost), False

def compute_t_i_multi(i: int, M: Dict,
                      w_star: float,
                      caps: np.ndarray,
                      z_star: float,
                      meta: Dict,
                      ladders: Dict | None = None,
                      ) -> Tuple[np.ndarray, np.ndarray, float, float, bool]:
    """
    Build (q_row, p_row) from (w_star, caps, z_star):
      split_policy ∈ {"uniform_subset", "min_cost"}
        - "uniform_subset": current bounded-participation splitter
        - "min_cost": greedy-by-price (requires ladders and a price reference)
    """
    # 1) split
    if ladders is None:
        raise ValueError("min_cost split requires ladders")
    # y_ref: the boundary at which capacity is priced.
    #   - interior: use w_star
    #   - boundary: use meta['y'] (upper or lower step), but pricing of unlocked
    #               capacity up to that boundary still uses the revealed step prices.
    y_ref = float(w_star)
    if isinstance(meta, dict):
        y_candidate = meta.get("y", None)
        if y_candidate is not None:
            y_ref = float(y_candidate)
    q_row = _min_cost_split(i, M, float(z_star), np.asarray(caps, float), ladders, y_ref)

    # 2) prices: one price across auctions
    p_row = np.full(int(M["J"]), float(w_star), dtype=float)

    # 3) cost & budget
    base_cost = cost_row(i, q_row, M)
    q_row, cost_new, u_new, feasible = apply_budget_policy(i, M, q_row, base_cost)
    return q_row, p_row, cost_new, u_new, feasible


def joint_best_response_plan(i: int, M: Dict) -> Tuple[np.ndarray, np.ndarray, bool, float]:
    # read policies (with defaults)

    ladders = build_ladders(i, M)
    w_star, caps, z_star, meta = sup_G_i_multi(
        i, M, ladders)

    q_row, p_row, cost, u_new, feasible = compute_t_i_multi(
        i, M, w_star, caps, z_star, meta, ladders)
    return q_row, p_row, feasible, u_new


# =====================================================
# Network
# =====================================================

# ------------------------------
# Priority queue helpers
# ------------------------------

def push(M: Dict, t: float, etype: int, payload: Tuple):
    M["seq"] += 1
    heapq.heappush(M["pq"], (float(t), int(M["seq"]), int(etype), payload))

def pop(M: Dict):
    return heapq.heappop(M["pq"]) if M["pq"] else None

def schedule_all_buyers(M: Dict, t0: float = 0.0):
    """Schedule one BUYER_COMPUTE per buyer at start time t0.
    If M["deterministic_sched"] is True, schedule at integer offsets (t0 + i).
    Otherwise, use jittered times for async interleaving.
    """
    det = bool(M.get("deterministic_sched", False))
    rng = M["rng"]
    for i in range(M["I"]):
        if det:
            t_i = t0 + float(i)
        else:
            t_i = t0 + float(rng.random() * M.get("jitter", 0.0))
        push(M, t_i, BUYER_COMPUTE, (i,))

def set_stable_order(M: dict, seed_order: int) -> None:
    """Install a stable buyer visitation order into the market."""
    I = int(M["I"])
    M["perm"] = np.random.default_rng(seed_order).permutation(I).astype(int)
    # Position map for micro-ordering on ties:
    pos = np.empty(I, dtype=int)
    pos[M["perm"]] = np.arange(I)
    M["perm_pos"] = pos
    M["jitter"] = 0.0  # make sure no randomization sneaks in

def schedule_all_buyers_stable(M: dict, t0: float = 0.0):
    """Schedule BUYER_COMPUTE once in the stable order, no jitter."""
    assert "perm" in M, "call set_stable_order(M, seed_order) first"
    M["pq"].clear()
    for k, i in enumerate(M["perm"]):
        # strictly increasing times guarantee deterministic processing order
        push(M, t0 + float(k), BUYER_COMPUTE, (int(i),))


# ------------------------------
# Event handlers
# ------------------------------

def handle_buyer_compute(M: Dict, i: int, verbose: bool = False, debug: bool = False):

    base_t = M["t"]
    old_u = u_i_current(i, M)
    q_row, p_row, feasible, u_new = joint_best_response_plan(i, M)
    det = bool(M.get("deterministic_sched", False))

    if det:
        # deterministic cadence: next tick exactly +1.0
        next_t = base_t + 1.0
        push(M, next_t, BUYER_COMPUTE, (i,))
    elif "perm_pos" in M:  # stable mode
        slot = 1e-9 * float(int(M["perm_pos"][i]))  # tiny, deterministic tie-break
        push(M, float(np.floor(M["t"])) + 1.0 + slot, BUYER_COMPUTE, (i,))
    else:
        next_t = base_t + 1.0 + float(M["rng"].random() * M.get("jitter", 0.0))
        push(M, next_t, BUYER_COMPUTE, (i,))

    if (not feasible) or (u_new <= old_u + float(M["epsilon"])):
        if verbose:
            print(f"BUYER_COMPUTE i={i}: no accepted update (feasible={feasible}, Δu={u_new-old_u:.6f})")
        return False

    # Accept plan
    M["gen"][i] += 1
    gen_now = int(M["gen"][i])

    J = M["J"]; tol = 1e-12
    changed = False
    instant = bool(M.get("instant_post", False))

    if instant:
        # Apply changes immediately; no POST_BID events.
        for j in range(J):
            if not M["adj"][i, j]:
                continue
            dq = abs(float(M["bid_q"][i, j]) - float(q_row[j]))
            dp = abs(float(M["bid_p"][i, j]) - float(p_row[j]))
            old_q = float(M["bid_q"][i, j]); new_q = float(q_row[j])
            if dq > tol or ((old_q > 0.0) or (new_q > 0.0)):
                M["bid_q"][i, j] = float(q_row[j])
                M["bid_p"][i, j] = float(p_row[j])
                changed = True
        if changed:
            # Reset apply idle counter just like POST_BID would
            M["events_since_apply"] = 0
            if verbose:
                print(f"BUYER_COMPUTE i={i}: applied immediately (gen={gen_now})")
        else:
            if verbose:
                print(f"BUYER_COMPUTE i={i}: plan equals current bids, nothing to apply")
        return changed

    # Asynchronous mode: schedule POST_BID events
    num_posts = 0
    for j in range(J):
        if not M["adj"][i, j]:
            continue
        dq = abs(float(M["bid_q"][i, j]) - float(q_row[j]))
        dp = abs(float(M["bid_p"][i, j]) - float(p_row[j]))
        old_q = float(M["bid_q"][i, j]); new_q = float(q_row[j])
        if dq > tol or ((old_q > 0.0) or (new_q > 0.0)):
            changed = True
            num_posts += 1
            t_post = base_t + float(M["rng"].random() * M.get("jitter", 0.0))
            push(M, t_post, POST_BID, (i, j, float(q_row[j]), float(p_row[j]), gen_now))
    if num_posts:
        M["pending_posts"] = M.get("pending_posts", 0) + num_posts
    if verbose:
        if changed:
            print(f"BUYER_COMPUTE i={i}: accepted plan (gen={gen_now}), posts scheduled: {num_posts}")
        else:
            print(f"BUYER_COMPUTE i={i}: plan equals current bids, nothing to post")
    return changed


def handle_post_bid(M: Dict, i: int, j: int, q: float, p: float, gen: int, verbose: bool = False, debug: bool = False):
    # Block if (i,j) is not connected
    if not M["adj"][i, j]:
        if M.get("pending_posts", 0) > 0:
            M["pending_posts"] -= 1
        if debug:
            print(f"POST_BID blocked (no edge): i={i}, j={j}")
        return False

    # Generation guard
    if (int(M["gen"][i]) != int(gen)):
        if verbose:
            print(f"POST_BID stale drop: i={i}, j={j}, gen={gen} (current gen={int(M['gen'][i])})")
        return False
    # fresh -> apply
    M["bid_q"][i,j] = float(q); M["bid_p"][i,j] = float(p)

    if M.get("pending_posts", 0) > 0:
        M["pending_posts"] -= 1
    M["events_since_apply"] = 0
    if verbose:
        print(f"POST_BID applied: i={i}, j={j}, (q,p)=({q:.4f},{p:.4f})")
    return True


# =====================================================
# Ladder Verification
# =====================================================
class LadderDict:
    """
    Price-ladder verification for market M.

    Expected keys in M:
      - "I": int
      - "J": int
      - "Q_max": array-like of length J
      - "bid_q": (I,J)
      - "bid_p": (I,J)
      - optional: "adj" (I,J) bool mask of feasible links
      - optional: "price_tol": float
      - optional: "seller_converged": (J,) bool
    """

    def __init__(self, M):
        self.M = M
        self._ladder_impossible = set()

    # --------------------------- helpers over M -----------------------------

    def _buyers_on(self, j):
        """Buyers i with positive quantity on seller j."""
        qcol = np.asarray(self.M["bid_q"])[:, j]
        active = qcol > 0.0 + EPS_Q
        if "adj" in self.M:
            active &= np.asarray(self.M["adj"])[:, j].astype(bool)
        return np.nonzero(active)[0]

    def _active_sellers_for(self, i):
        """Sellers j with positive quantity for buyer i."""
        qrow = np.asarray(self.M["bid_q"])[i, :]
        mask = qrow > 0.0 + EPS_Q
        if "adj" in self.M:
            mask &= np.asarray(self.M["adj"])[i, :].astype(bool)
        return np.nonzero(mask)[0]

    def _seller_shell_1hop(self, j):
        """1-hop seller shell: sellers ℓ that share ≥1 active buyer with seller j."""
        shell = set()
        buyers = self._buyers_on(j)
        if buyers.size == 0:
            return shell
        bid_q = np.asarray(self.M["bid_q"])
        for i in buyers:
            sellers_i = np.nonzero(bid_q[i, :] > 0.0 + EPS_Q)[0]
            for ell in sellers_i:
                if ell == j:
                    continue
                shell.add(ell)
        return shell

    def _seller_converged(self, j):
        conv = self.M.get("seller_converged", None)
        if conv is None:
            return True
        return bool(np.asarray(conv)[j])

    def _pstar(self, j):
        """Marginal winning price on seller j (0.0 if undersubscribed)."""
        I = int(self.M["I"])
        Qj = float(np.asarray(self.M["Q_max"])[j])
        qcol = np.asarray(self.M["bid_q"])[:, j]
        pcol = np.asarray(self.M["bid_p"])[:, j]
        idx = np.nonzero(qcol > 0.0 + EPS_Q)[0]
        if idx.size == 0:
            return 0.0
        bids = [(int(i), float(qcol[i]), float(pcol[i])) for i in idx]
        bids.sort(key=lambda t: t[2], reverse=True)
        cum = 0.0
        for (i, q, p) in bids:
            if cum + q >= Qj - EPS_Q:
                return float(p)
            cum += q
        return 0.0

    def _winners_on(self, j):
        """Buyers who fill up to Q_max[j] at current bids."""
        Qj = float(np.asarray(self.M["Q_max"])[j])
        qcol = np.asarray(self.M["bid_q"])[:, j]
        pcol = np.asarray(self.M["bid_p"])[:, j]
        idx = np.nonzero(qcol > 0.0 + EPS_Q)[0]
        if idx.size == 0:
            return []
        bids = [(int(i), float(qcol[i]), float(pcol[i])) for i in idx]
        bids.sort(key=lambda t: t[2], reverse=True)
        winners = []
        cum = 0.0
        for i, q, p in bids:
            if cum + EPS_Q >= Qj:
                break
            take = min(q, max(Qj - cum, 0.0))
            if take > 0.0:
                winners.append(i)
                cum += take
        return winners

    # ---------------------- ladder precheck ------------------------------

    def _ladder_precheck(self, j):
        if not self._seller_converged(j):
            return False, f"seller {j} not converged (shell not saturated)"
        pj_star = self._pstar(j)
        if pj_star <= 0.0:
            return False, f"seller {j} undersubscribed / no marginal tier (p*_j=0)"
        shell = self._seller_shell_1hop(j)
        if not shell:
            return False, f"no 1-hop neighbors with shared active buyers for seller {j}"
        if all(not self._seller_converged(ell) for ell in shell):
            return False, f"no converged neighbors with a marginal tier around seller {j}"
        Wj = self._winners_on(j)
        if not Wj:
            return False, f"no winners on seller {j} (empty W^j)"
        has_valid_neighbor = any(self._seller_converged(ell) and self._pstar(ell) > 0.0 for ell in shell)
        if not has_valid_neighbor:
            return False, f"no converged neighbors with a marginal tier around seller {j}"
        return True, ""

    # ---------------------- price ladder core check -------------------------

    def _price_ladder_checks(self, j, hops=1):
        ok, reason = self._ladder_precheck(j)
        if not ok:
            print(f"[ladder] seller {j}: skipped — {reason}")
            return pd.DataFrame({"__no_ladder_reason__": [reason]})

        pj_star = self._pstar(j)
        shell = self._seller_shell_1hop(j)
        Wj = set(self._winners_on(j))
        tol = float(self.M.get("price_tol", 1e-9))
        rows = []
        bid_q = np.asarray(self.M["bid_q"])
        bid_p = np.asarray(self.M["bid_p"])

        for i in Wj:
            pi_star = float(bid_p[i, j])
            sellers_i = set(self._active_sellers_for(i))
            for ell in (sellers_i - {j}) & set(shell):
                if not self._seller_converged(ell):
                    continue
                p_ell_star = self._pstar(ell)
                if p_ell_star >= pj_star - tol:
                    pair = (j, ell)
                    if pair not in self._ladder_impossible:
                        print(f"[ladder] seller {j}: cannot build vs {ell} "
                              f"(p*_ell={p_ell_star:.3f} ≥ p*_j={pj_star:.3f})")
                        self._ladder_impossible.add(pair)
                    continue
                if p_ell_star <= 0.0 + tol:
                    continue

                winners_ell = self._winners_on(ell)
                for k in winners_ell:
                    if k in Wj:
                        continue
                    qk_ell = float(bid_q[k, ell])
                    if qk_ell <= 0.0 + EPS_Q:
                        continue
                    pk_ell = float(bid_p[k, ell])
                    ok_left  = (p_ell_star <= pk_ell + tol)
                    ok_mid   = (pk_ell <  pj_star - tol)
                    ok_right = (pj_star  <= pi_star + tol)
                    rows.append({
                        "ell": int(ell),
                        "k": int(k),
                        "j": int(j),
                        "i": int(i),
                        "p_ell*": float(p_ell_star),
                        "p_k*": float(pk_ell),
                        "p_j*": float(pj_star),
                        "p_i*": float(pi_star),
                        "ok_left": ok_left,
                        "ok_mid": ok_mid,
                        "ok_right": ok_right,
                    })

        df = pd.DataFrame(rows)
        if df.empty:
            print(f"[ladder] seller {j}: no valid (ell,k,i) tuples")
            return pd.DataFrame({"__no_ladder_reason__": [f"no valid (ell,k,i) tuples found around seller {j}"]})
        df["all_ok"] = df["ok_left"] & df["ok_mid"] & df["ok_right"]
        return df

    # --------------------------- public API ---------------------------------

    def check_all_price_ladders(self, t=0.0, hops=1):
        frames = []
        reasons = []
        J = int(self.M["J"])
        for j in range(J):
            out = self._price_ladder_checks(j, hops=hops)
            if "__no_ladder_reason__" in out.columns:
                reasons.append((j, out["__no_ladder_reason__"].iloc[0]))
            else:
                out = out.copy()
                out["dt"] = t
                frames.append(out)

        df = pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()
        for sid, msg in reasons:
            print(f"[ladder] seller {sid}: {msg}")

        if df.empty:
            print("[ladder] No ladder tuples found.")
            return df

        bad = df[~df["all_ok"]]
        good = df[df["all_ok"]]

        if not good.empty:
            margin_left  = (good["p_k*"] - good["p_ell*"]).min()
            margin_mid   = (good["p_j*"] - good["p_k*"]).min()
            margin_right = (good["p_i*"] - good["p_j*"]).min()
            n_pairs = good[["ell", "j"]].drop_duplicates().shape[0]
            print(f"\n[ladder] t={t:.2f} — PRICE LADDER HOLDS on {len(good)} tuples "
                  f"across {n_pairs} (j,ℓ) pairs\n"
                  f"tightest margins:\n"
                  f" (pk−pℓ*): {margin_left:.3g}, (p*j−pk): {margin_mid:.3g}, (pi−p*j): {margin_right:.3g}")

        if not bad.empty:
            print("\n[ladder] WARNING: violations detected (pℓ* ≤ pk < p*j ≤ pi):")
            show = bad.copy()
            for c in ["p_ell*", "p_k*", "p_j*", "p_i*"]:
                show[c] = show[c].round(3)
            print(show.to_string(index=False))

        return df

    def _ladder_reason_empty(self):
        J = int(self.M["J"])
        zeros = []
        for j in range(J):
            if self._pstar(j) == 0.0:
                zeros.append(j)
        if zeros:
            ids = ", ".join(str(x) for x in zeros)
            return f"No ladder: undersubscribed sellers with p* = 0 (sellers: {ids})."
        return ("No ladder: graph has only trivial shells "
                "(each seller shares ≤1 buyer, so (ℓ,k,j,i) cannot form).")

    def print_final_ladder_report(self, t_now=0.0, hops=1):
        out = self.check_all_price_ladders(t_now, hops=hops)
        if out.empty:
            print(f"[Final Ladder] {self._ladder_reason_empty()}")
            return
        if out["all_ok"].all():
            print(f"\n[Final Ladder] Monotone price ladder verified at t={t_now:.2f} "
                  "(pℓ ≤ pk < pj ≤ pi).")
            with pd.option_context("display.max_rows", None, "display.width", 100):
                view = out[["ell","k","j","i","p_ell*","p_k*","p_j*","p_i*"]].drop_duplicates().round(3)
                print(view.to_string(index=False))
        else:
            bad = out[out["all_ok"] == False]
            print("\n[Final Ladder] WARNING: violations remain.")
            with pd.option_context("display.max_rows", None, "display.width", 100):
                print(bad.to_string(index=False))




# =====================================================
# Reporting
# =====================================================

@dataclass
class MarketMetrics:
    # core arrays
    a_mat: np.ndarray           # (I,J) allocations a_ij
    buyer_alloc: np.ndarray     # (I,)
    buyer_value: np.ndarray     # (I,)
    buyer_util: np.ndarray      # (I,)
    buyer_marg: np.ndarray      # (I,)
    bid_p: np.ndarray           # (I,J)
    bid_q: np.ndarray           # (I,J)
    adj:   np.ndarray           # (I,J) bool

    # quick seller totals
    alloc_j: np.ndarray         # (J,)
    revenue_j: np.ndarray       # (J,)
    Q_max: np.ndarray           # (J,)
    avg_bid_j: np.ndarray       # (J,)

# --- Definitions (for clarity) ---
# avg_bid_j: allocation-weighted average posted bid price at seller j:
#            \bar p^{bid}_j = (\sum_i a_{ij} p_i) / (\sum_i a_{ij}).
# avg_bid  : column copied from avg_bid_j for convenience in reports.
# buyer_marg[i]: buyer i's marginal valuation at their total allocation z_i = \sum_j a_{ij},
#                i.e., θ'_i(z_i; M).
# E_j      : allocation-weighted average marginal valuation among buyers served by seller j:
#            E_j = (\sum_i a_{ij} · θ'_i(z_i)) / (\sum_i a_{ij}).
# V_j      : allocation-weighted variance of buyer marginal valuations at seller j:
#            V_j = (\sum_i a_{ij} · (θ'_i(z_i) − E_j)^2) / (\sum_i a_{ij}).

def compute_market_metrics(M: Dict) -> MarketMetrics:
    I, J = int(M["I"]), int(M["J"])
    adj   = np.asarray(M["adj"], bool)
    bid_q = np.asarray(M.get("bid_q", np.zeros((I, J))), float)
    bid_p = np.asarray(M.get("bid_p", np.zeros((I, J))), float)

    a_mat       = np.zeros((I, J), float)
    buyer_alloc = np.zeros(I, float)
    buyer_value = np.zeros(I, float)
    buyer_util  = np.zeros(I, float)
    buyer_marg  = np.zeros(I, float)

    # Single pass over buyers to populate core arrays
    for i in range(I):
        a_vec, z = a_row(i, M)
        a_mat[i, :]    = a_vec
        buyer_alloc[i] = z
        val_i          = theta_i(i, z, M)
        buyer_value[i] = val_i
        cost_i         = cost_row(i, a_vec, M)
        buyer_util[i]  = val_i - cost_i
        buyer_marg[i]  = theta_i_prime(i, z, M) if z > 0.0 else 0.0

    alloc_j = a_mat.sum(axis=0)

    # Revenue by seller (integral of seller price ladder over awarded a_ij)
    revenue_j = np.zeros(J, float)
    for j in range(J):
        if alloc_j[j] <= 0.0:
            continue
        for i in range(I):
            a_ij = a_mat[i, j]
            if a_ij > 0.0:
                revenue_j[j] += float(integral_P_i_j(i, j, a_ij, M))

    # Allocation-weighted avg posted bid at each seller
    avg_bid_j = per_seller_alloc_weighted_bid(M)

    Q_max = np.asarray(M["Q_max"], float)

    return MarketMetrics(
        a_mat=a_mat, buyer_alloc=buyer_alloc, buyer_value=buyer_value,
        buyer_util=buyer_util, buyer_marg=buyer_marg, bid_p=bid_p,
        bid_q=bid_q, adj=adj, alloc_j=alloc_j, revenue_j=revenue_j, Q_max=Q_max,
        avg_bid_j=avg_bid_j,
    )


def market_report_from(metrics: MarketMetrics, level: str = "seller") -> pd.DataFrame:
    a_mat       = metrics.a_mat
    buyer_alloc = metrics.buyer_alloc
    buyer_value = metrics.buyer_value
    buyer_util  = metrics.buyer_util
    buyer_marg  = metrics.buyer_marg
    alloc_j     = metrics.alloc_j
    revenue_j   = metrics.revenue_j
    avg_bid_j   = metrics.avg_bid_j
    Q_max       = metrics.Q_max

    I, J = a_mat.shape

    # Attribute buyer totals to sellers proportionally to a_ij / z_i
    value_j = np.zeros(J, float)
    util_j  = np.zeros(J, float)
    mask_pos = buyer_alloc > 0
    if np.any(mask_pos):
        W = np.zeros_like(a_mat)
        # rows of W sum to 1 over sellers where a_ij>0
        W[mask_pos, :] = (a_mat[mask_pos, :].T / buyer_alloc[mask_pos]).T
        value_j = W.T @ buyer_value
        util_j  = W.T @ buyer_util

    # --- Readable E_j and V_j ---
    # For each seller j:
    #   weights w_i^j = a_ij / A_j where A_j = sum_i a_ij
    #   E_j = sum_i w_i^j * buyer_marg[i]
    #   V_j = sum_i w_i^j * (buyer_marg[i] - E_j)^2
    E_j = np.zeros(J, float)
    V_j = np.zeros(J, float)
    for j in range(J):
        A_j = float(alloc_j[j])
        if A_j <= 0.0:
            continue
        a_col = a_mat[:, j]
        w = a_col / A_j
        m = buyer_marg  # shorthand
        Ej = float(np.dot(w, m))
        E_j[j] = Ej
        V_j[j] = float(np.dot(w, (m - Ej)**2))

    # avg_bid column mirrors avg_bid_j for convenience
    df = pd.DataFrame({
        "seller":   np.arange(J),
        "alloc":    alloc_j,
        "value":    value_j,
        "util":     util_j,
        "revenue":  revenue_j,
        "E_j":      E_j,
        "V_j":      V_j,
        "avg_bid":  avg_bid_j,
        "Q_max":    Q_max,
    }).round(3)

    if level == "market":
        totals = df[["alloc", "value", "util", "revenue"]].sum()
        avgs   = df[["E_j", "avg_bid"]].mean()
        return pd.DataFrame([{**totals.to_dict(), **avgs.to_dict()}]).round(3)

    return df

def record_market_snapshot_from(metrics: MarketMetrics,
                                interval: float,
                                market_history: pd.DataFrame) -> pd.DataFrame:
    I, J = metrics.a_mat.shape
    rows = []
    for i in range(I):
        z_i    = float(metrics.buyer_alloc[i])
        v_i    = float(metrics.buyer_value[i])
        u_i    = float(metrics.buyer_util[i])
        p_marg = float(metrics.buyer_marg[i])
        for j in np.where(metrics.adj[i])[0]:
            rows.append({
                "interval": interval,
                "Seller":   int(j),
                "Buyer":    int(i),
                "q_i":      float(metrics.bid_q[i, j]),
                "p_i":      float(metrics.bid_p[i, j]),
                "a_i":      float(metrics.a_mat[i, j]),
                "z_i":      z_i,
                "p_marg":   p_marg if z_i > 0.0 else 0.0,
                "v_i":      v_i,
                "u_i":      u_i,
                "c_i":      float(v_i - u_i),
                "diff":     0,
            })
    if rows:
        snap = pd.DataFrame(rows)
        return pd.concat([market_history, snap], ignore_index=True)
    return market_history

def print_round_from_metrics(metrics: MarketMetrics,
                            round_decimals: int = 3,
                            full_index: bool = True,
                            use_adj: bool = False,
                            header: str | None = None) -> pd.DataFrame:
    a_mat = metrics.a_mat
    bid_q = metrics.bid_q
    bid_p = metrics.bid_p
    adj = metrics.adj
    I, J = a_mat.shape
    base_idx = list(range(I)) if full_index else sorted(np.where(metrics.buyer_alloc> -1)[0].tolist())
    # ---------------- Buyer Totals ----------------
    totals = pd.DataFrame({
            "Buyer": np.array(base_idx, dtype=int),
            "z_i": metrics.buyer_alloc,
            "p_marg": metrics.buyer_marg,
            "v_i": metrics.buyer_value,
            "u_i": metrics.buyer_util,
            "c_i": metrics.buyer_value - metrics.buyer_util,
        })
    totals = totals.set_index("Buyer").reindex(base_idx).reset_index()
    for c in totals.select_dtypes(include="number").columns:
        if c != "Buyer":
            totals[c] = totals[c].round(round_decimals)
    totals.columns = pd.MultiIndex.from_product([["Buyer Totals"], totals.columns])
    blocks = [totals]
    # ---------------- Seller blocks ----------------
    for j in range(J):
        sub = pd.DataFrame({
                "Buyer": np.array(base_idx, dtype=int),
                "q_i": bid_q[:, j],
                "p_i": bid_p[:, j],
                "a_i": a_mat[:, j],
            }).set_index("Buyer").reindex(base_idx)
        # Decide which cells are blanks
        if use_adj:
            no_edge = pd.Series([not bool(adj[b, j]) if (0 <= b < adj.shape[0]) else True for b in base_idx], index=base_idx)
            mask_blank = no_edge
        else:
            # no bid
            mask_blank = ((sub["q_i"].fillna(0.0) == 0.0) & (sub["p_i"].fillna(0.0) == 0.0))

        def fmt(series: pd.Series) -> pd.Series:
            s = series.copy()
            s = s.where(~mask_blank, np.nan)
            s = s.where(s.isna(), s.round(round_decimals))
            return s.astype(object).where(~s.isna(), "--")

        out = pd.DataFrame(index=sub.index)
        out["Buyer"] = out.index.astype(int)
        out["q_i"] = fmt(sub["q_i"])
        out["p_i"] = fmt(sub["p_i"])
        out["a_i"] = fmt(sub["a_i"])

        out = out.reset_index(drop=True)
        out.columns = pd.MultiIndex.from_product([[f"Seller {j}"], out.columns])
        blocks.append(out)

    wide = pd.concat(blocks, axis=1, join="outer")
    print_df(wide, header=(header or "Market snapshot"), index=False)
    return wide

def print_df(df: pd.DataFrame,
          header: Optional[str] = None,
          index: bool = False,
          max_rows: Optional[int] = 200,
          max_cols: Optional[int] = None,
          width: int = 120,
          round_decimals: Optional[int] = None) -> None:
    out = df.copy()
    if round_decimals is not None:
        num_cols = out.select_dtypes(include="number").columns
        out[num_cols] = out[num_cols].round(round_decimals)

    with pd.option_context(
        "display.max_rows", max_rows,
        "display.max_columns", max_cols,
        "display.width", width,
        "display.expand_frame_repr", False,
    ):
        text = out.to_string(index=index)

    if header:
        print(f"\n{header}\n{text}")
    else:
        print(f"\n{text}")


def alloc_weighted_avg_bid(M: Dict, j: int) -> float:
    """Allocation-weighted average posted bid at seller j."""
    a_col = np.asarray([a_row(i, M)[0][j] for i in range(M["I"])], float)
    p_col = np.asarray(M["bid_p"][:, j], float)
    A = float(a_col.sum())
    return float((a_col * p_col).sum() / A) if A > 0 else 0.0


def per_seller_alloc_weighted_bid(M: dict) -> np.ndarray:
    """Allocation-weighted avg bid price per seller (vectorized over j)."""
    I, J = int(M["I"]), int(M["J"])
    out = np.zeros(J, float)
    for j in range(J):
        a_col = np.zeros(I, float)
        for i in range(I):
            a_vec, _ = a_row(i, M)
            a_col[i] = float(a_vec[j])
        A = float(a_col.sum())
        if A > 0:
            out[j] = float((a_col * np.asarray(M["bid_p"][:, j], float)).sum() / A)
    return out

def per_seller_thresholds(M: dict) -> np.ndarray:
    """Return clearing threshold p*_j per seller j."""
    J = M["J"]
    out = np.zeros(J)
    for j in range(J):
        q = M["bid_q"][:, j]
        p = M["bid_p"][:, j]
        mask = q > 0
        if not np.any(mask):
            continue
        qj, pj = q[mask], p[mask]
        idx = np.argsort(-pj)
        qj, pj = qj[idx], pj[idx]
        cum = np.cumsum(qj)
        thr = pj[np.searchsorted(cum, M["Q_max"][j], side="right") - 1]
        out[j] = thr
    return out


def _adj_mask(M):
    """Return (I,J) bool adjacency; if missing, assume fully connected."""
    I, J = int(M["I"]), int(M["J"])
    adj = M.get("adj")
    if adj is None:
        return np.ones((I, J), dtype=bool)
    return np.asarray(adj, dtype=bool)

def classify_buyers(M: dict, tol: float = 1e-12) -> pd.DataFrame:
    """
    Classify buyers at convergence, respecting adjacency:
      - has_pos_bid: any positive bid on a connected edge
      - zero_alloc_pos_bid: z_i == 0 but posted positive qty on some connected edge
      - zero_bid: no positive bids on any connected edge
      - zero_bid_no_gain: zero_bid AND JBR would also pick zero (on connected edges)
      - deg_i: number of connected sellers
    """
    I, J = int(M["I"]), int(M["J"])
    adj = _adj_mask(M)

    rows = []
    for i in range(I):
        # Connected sellers for i
        conn = adj[i, :]
        deg_i = int(np.count_nonzero(conn))

        # Allocation snapshot (a_row already yields zeros for non-bids; we’ll still mask)
        a_vec, z_i = a_row(i, M)
        a_conn = np.where(conn, a_vec, 0.0)
        z_i_conn = float(np.sum(a_conn))

        # Positive bids only on connected edges
        bid_q_i = np.asarray(M["bid_q"][i, :], float)
        has_pos_bid = bool(np.any(bid_q_i[conn] > tol))
        zero_bid = (not has_pos_bid)  # only considering connected edges
        zero_alloc_pos_bid = (z_i_conn <= tol) and has_pos_bid

        # For zero-bid buyers, check if JBR would still choose zero *given connected edges*
        zero_bid_no_gain = False
        if zero_bid and deg_i > 0:
            ladders = build_ladders(i, M)  # build_ladders already honors adjacency
            _, _, z_star, _ = sup_G_i_multi(i, M, ladders)
            zero_bid_no_gain = (float(z_star) <= tol)
        elif zero_bid and deg_i == 0:
            # No connected sellers: treat as structurally out (not a failure to bid)
            zero_bid_no_gain = True

        rows.append({
            "buyer": i,
            "deg_i": deg_i,
            "z_i": float(z_i_conn),
            "has_pos_bid": has_pos_bid,
            "zero_alloc_pos_bid": zero_alloc_pos_bid,
            "zero_bid": zero_bid,
            "zero_bid_no_gain": zero_bid_no_gain,
        })
    return pd.DataFrame(rows)


def per_seller_outbid_losers(M: dict, tol: float = 1e-12) -> np.ndarray:
    """
    Per seller j: count buyers who posted positive qty on (i,j) AND are connected to j,
    but received zero allocation at j.
    """
    I, J = int(M["I"]), int(M["J"])
    adj = _adj_mask(M)
    counts = np.zeros(J, dtype=int)
    for i in range(I):
        a_vec, _ = a_row(i, M)
        for j in range(J):
            if not adj[i, j]:
                continue
            if (M["bid_q"][i, j] > tol) and (a_vec[j] <= tol):
                counts[j] += 1
    return counts


# =====================================================
# Helpers
# =====================================================

# ------------------------------
# Initialization helpers
# ------------------------------

def randomize_bids(M: Dict, seed: int ) -> None:

    I, J = int(M["I"]), int(M["J"])

    # Clear any existing bids
    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)

    adj = np.asarray(M["adj"], bool)

    def buyer_rng(i: int) -> np.random.Generator:
        # Independent per-buyer stream → stable w.r.t. other randomness
        return np.random.default_rng(np.int64(seed) + np.int64(i) * 1_000_003)

    for i in range(I):
        rng_i = buyer_rng(i)
        z_total = float(rng_i.uniform(0.0, float(M["qbar"][i])))
        if z_total <= 1e-15:
            continue
        idxs = np.flatnonzero(adj[i])
        if idxs.size == 0:
            continue

        share = z_total / idxs.size
        p_uniform = float(theta_i_prime(i, z_total, M))  # same price across auctions
        for j in idxs:
            M["bid_q"][i, j] = share
            M["bid_p"][i, j] = p_uniform
    reserve = M["reserve"]
    Q_max = M["Q_max"]
    #for j in J:
     #   M["bid_q"][0, j] = reserve[j]
      #  M["bid_p"][0, j] = Q_max[j]
    return

def fair_bids(
    M: dict,
    seed: int | None = None,
    mode: str = "equal",          # "equal" or "capacity"
    enforce_budget: bool = False  # uniformly scale down if cost > b_i
) -> None:
    """
    Initialize bids to a uniform-price, fair-share split for each buyer.

    For buyer i:
      - Let S_i = { j : adj[i, j] = True }.
      - Planned total z_i = min(qbar[i], sum_j∈S_i Q_max[j]).
      - Split z_i across S_i:
          * "equal":        z_i^j = z_i / |S_i|
          * "capacity":     z_i^j ∝ Q_max[j]  (normalized over S_i)
      - Set a uniform price p_i = θ'_i(z_i) on all j ∈ S_i.
      - If enforce_budget is True and cost(z_i^•) > b_i, scale all z_i^j by
        a factor s ∈ (0, 1] (found by bisection) so that cost ≤ b_i.
    """
    import numpy as np

    I, J = int(M["I"]), int(M["J"])
    adj  = np.asarray(M["adj"], dtype=bool)
    Qmax = np.asarray(M["Q_max"], dtype=float)
    qbar = np.asarray(M["qbar"], dtype=float)
    bvec = np.asarray(M["b"], dtype=float)

    # clear existing bids
    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)

    # optional RNG (not used here, but kept for API compatibility)
    _ = np.random.default_rng(seed) if seed is not None else None

    for i in range(I):
        idxs = np.flatnonzero(adj[i])
        if idxs.size == 0:
            continue

        # Buyer’s reachable capacity and planned total
        cap_reachable = float(Qmax[idxs].sum())
        if cap_reachable <= 0.0:
            continue

        z_plan = min(float(qbar[i]), cap_reachable)
        if z_plan <= 0.0:
            continue

        # Fair split across adjacent sellers
        if mode == "capacity":
            w = Qmax[idxs].astype(float)
            wsum = float(w.sum())
            shares = (w / wsum) if wsum > 0 else np.full(idxs.size, 1.0 / idxs.size)
        else:  # "equal"
            shares = np.full(idxs.size, 1.0 / idxs.size, dtype=float)

        q_row = z_plan * shares
        p_uni = float(theta_i_prime(i, z_plan, M))  # uniform price for buyer i

        # Optional: enforce budget via uniform scaling of quantities
        if enforce_budget:
            def cost_for(scale: float) -> float:
                # Temporarily price uniformly at p_uni; your cost_row uses
                # the seller price ladders, so we only need to hand it q's.
                return float(cost_row(i, scale * q_row_full, M))

            # Build a full J-vector for cost_row
            q_row_full = np.zeros(J, dtype=float)
            q_row_full[idxs] = q_row

            # Quick check; if over budget, bisection on scale in (0,1]
            c0 = float(cost_row(i, q_row_full, M))
            if c0 > float(bvec[i]) + 1e-12:
                lo, hi = 0.0, 1.0
                for _ in range(40):  # ~1e-12 precision
                    mid = 0.5 * (lo + hi)
                    if cost_for(mid) <= float(bvec[i]):
                        lo = mid
                    else:
                        hi = mid
                scale = lo
                q_row *= scale
                # keep uniform price tied to actual total quantity
                z_plan = float(q_row.sum())
                p_uni  = float(theta_i_prime(i, z_plan, M))

        # Commit bids
        M["bid_q"][i, idxs] = q_row
        M["bid_p"][i, idxs] = p_uni

def make_membership_adj(I: int, J: int,
                        percent_multi: float,
                        w: Optional[np.ndarray] = None,
                        rng: Optional[np.random.Generator] = None) -> np.ndarray:
    """
    Builds an (I x J) boolean adjacency with bounded participation (degree ≤ 2).
    Assumptions:
      - J ≥ 2
      - 0 ≤ percent_multi ≤ 1
      - If w is provided, it is length-J and normalized (sum=1, nonnegative)
    Rule per buyer i:
      - With probability percent_multi → degree K=2, else K=1
      - Choose K distinct sellers without replacement using probability weights w
    """
    if rng is None:
        print("Warning: Adjacency array is non-deterministic (not reproducible)!")
        rng = np.random.default_rng()
    if w is None:
        w = np.full(J, 1.0 / J)

    adj = np.zeros((I, J), dtype=bool)
    for i in range(I):
        K = 2 if rng.random() < percent_multi else 1
        idx = rng.choice(J, size=K, replace=False, p=w)
        adj[i, idx] = True
    return adj

import numpy as np

def local_award_for_seller(M, j, *, exclude_buyers=None):
    """
    Compute a one-shot PSP clear for seller j from the *current snapshot* in M,
    returning (awarded_vector, p_star). Pure function: does not mutate M.

    Rules:
      - Sort active bids (q>0 and (adj True if provided)) by price desc.
      - Fill to capacity Q_max[j].
      - If the marginal tier is a tie at price p*, split the remaining capacity
        proportionally to requested quantities among *only* those tied bidders.
      - Charge the threshold price p* to all served buyers.
      - If undersubscribed (sum q <= Q_max[j]): everyone gets their q, p* = 0.0.

    Parameters
    ----------
    M : dict
        Market dictionary with at least:
          I, J (ints), Q_max (J,), bid_q (I,J), bid_p (I,J).
        Optional: adj (I,J) bool mask of feasible links.
    j : int
        Seller index.
    exclude_buyers : Iterable[int] | None
        Optional set/list of buyer indices to ignore (treated as q=0).

    Returns
    -------
    a_j : np.ndarray shape (I,)
        Awarded quantities to *each buyer* at seller j.
    p_star : float
        Threshold (marginal) price for seller j; 0.0 if undersubscribed.
    """
    I = int(M["I"])
    Qj = float(np.asarray(M["Q_max"])[j])
    bid_q = np.asarray(M["bid_q"], dtype=float)[:, j].copy()
    bid_p = np.asarray(M["bid_p"], dtype=float)[:, j].copy()

    # Feasibility mask (adj) and optional exclusions
    if "adj" in M:
        mask = np.asarray(M["adj"])[:, j].astype(bool)
        bid_q[~mask] = 0.0
    if exclude_buyers:
        bid_q[np.array(list(exclude_buyers), dtype=int)] = 0.0

    # Active bids only
    idx = np.nonzero(bid_q > 0.0)[0]
    if idx.size == 0:
        return np.zeros(I, dtype=float), 0.0

    bids = [(int(i), float(bid_q[i]), float(bid_p[i])) for i in idx]
    bids.sort(key=lambda t: t[2], reverse=True)  # by price desc

    a = np.zeros(I, dtype=float)
    cum = 0.0

    # Quick undersubscription check
    total_q = sum(q for _, q, _ in bids)
    if total_q < Qj - 1e-9:
        for i, q, _ in bids:
            a[i] = q
        return a, 0.0  # no binding threshold

    # Fill strictly-above-threshold tiers
    k = 0
    while k < len(bids):
        i, q, p = bids[k]
        # Look ahead to see if next price is strictly lower (then this is a strict tier)
        next_is_lower = (k == len(bids) - 1) or (bids[k+1][2] < p - 0.0)  # exact tie only if equal
        if next_is_lower:
            # Strict tier: can we take entire q?
            if cum + q <= Qj + 1e-12:
                take = min(q, Qj - cum)
                a[i] += max(take, 0.0)
                cum += take
                if cum >= Qj - 1e-12:
                    # Filled exactly at a strict tier; p* is the price of this tier
                    return a, float(p)
                k += 1
                continue
            else:
                # We hit capacity inside this single strict bidder (rare because divisible & sorted)
                rem = max(Qj - cum, 0.0)
                a[i] += rem
                cum += rem
                return a, float(p)
        else:
            # We are at the *start* of a tie tier at price p
            p_star = p
            # collect all bidders at this tied price
            tie_start = k
            while k < len(bids) and abs(bids[k][2] - p_star) <= 0.0:
                k += 1
            tie_end = k  # slice [tie_start, tie_end) are the tied bidders at p*
            # Allocate fully all strictly-above tiers already done; now split the remainder across ties
            rem = max(Qj - cum, 0.0)
            if rem <= 1e-12:
                # Already filled before the tie — threshold determined by previous price
                return a, float(p_star)
            tie_total_q = sum(bids[t][1] for t in range(tie_start, tie_end))
            if tie_total_q <= rem + 1e-12:
                # Tie group fits entirely; allocate all of them and continue to lower prices
                for t in range(tie_start, tie_end):
                    i_t, q_t, _ = bids[t]
                    a[i_t] += q_t
                    cum += q_t
                if cum >= Qj - 1e-12:
                    return a, float(p_star)
                # Continue to next (lower) price levels; but note p* would then actually be LOWER.
                # However, by definition p* is the *marginal* threshold: if we pass the tie entirely,
                # the true threshold will be found later. So keep looping.
                continue
            else:
                # Tie-splitting at the marginal tier p*
                if tie_total_q <= 0.0:
                    return a, float(p_star)
                for t in range(tie_start, tie_end):
                    i_t, q_t, _ = bids[t]
                    share = rem * (q_t / tie_total_q)
                    a[i_t] += share
                cum = Qj
                return a, float(p_star)

    # If we exit the loop without returning, capacity was matched exactly at the last strict tier
    # Use its price as p*
    last_price = bids[min(len(bids)-1, k-1)][2]
    return a, float(last_price)

def record_seeds(base_seed: int,
                 *,
                 I: int,
                 J: int,
                 percents,
                 seed_model: int | None = None,
                 seed_bids: int | None = None,
                 seed_adj: int | None = None,
                 seed_sched: int | None = None,
                 verbose: bool = True) -> dict:
    """
    Collect, print, and optionally save the active random seeds for the experiment.

    Parameters
    ----------
    base_seed : int
        Master seed defining the base for all other seeds.
    I, J : int
        Market dimensions, for context.
    percents : iterable
        Participation levels tested in this experiment.
    seed_model, seed_bids, seed_adj, seed_sched : int or None
        Optional overrides. If None, derived deterministically from base_seed.

    Returns
    -------
    seeds : dict
        Dictionary of resolved seeds and derived per-level adjacency seeds.
    """
    # Resolve all seeds deterministically if not given
    seed_model = base_seed if seed_model is None else seed_model
    seed_bids  = base_seed + 17 if seed_bids is None else seed_bids
    seed_sched = base_seed + 313 if seed_sched is None else seed_sched
    seed_adj0  = base_seed if seed_adj is None else seed_adj

    seeds = {
        "timestamp": datetime.now().isoformat(timespec="seconds"),
        "I": I,
        "J": J,
        "percents": list(map(float, percents)),
        "base_seed": base_seed,
        "seed_model": seed_model,
        "seed_bids": seed_bids,
        "seed_sched": seed_sched,
        "seed_adj_base": seed_adj0,
        "seed_adj_per_level": {
            f"{int(p*100)}%": seed_adj0 + 1009 * li
            for li, p in enumerate(percents)
        }
    }

    if verbose:
        print("=== Random Seed Configuration ===")
        for k, v in seeds.items():
            if isinstance(v, dict):
                continue
            print(f"{k:18s}: {v}")
        print("Adjacency per level:")
        for label, sval in seeds["seed_adj_per_level"].items():
            print(f"  {label:>6s} → {sval}")
        print("=================================\n")


    return seeds


# =====================================================
# Plotting
# =====================================================

# ------------------------------
# Comparison/ averaging plots
# ------------------------------

def plot_shared_buyer_surface_z0z1(M, i, sellers=(0,1), steps=60, mode="fixed_w", w_fixed=None,
                                   mark_current=True, with_contours=True, elev=25, azim=-120):
    """
    3D surface: u_i over (z0, z1) where z0 = alloc from seller j0, z1 = alloc from seller j1.
    Uniform price across the two sellers; price can be fixed or θ'(z0+z1).
    """
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D  # noqa

    j0, j1 = sellers
    z0s = np.linspace(0.0, float(M["Q_max"][j0]), steps)
    z1s = np.linspace(0.0, float(M["Q_max"][j1]), steps)
    Z0, Z1 = np.meshgrid(z0s, z1s)
    U = np.zeros_like(Z0)

    # snapshot
    q0_old, q1_old = float(M["bid_q"][i, j0]), float(M["bid_q"][i, j1])
    p0_old, p1_old = float(M["bid_p"][i, j0]), float(M["bid_p"][i, j1])

    if mode == "fixed_w":
        if w_fixed is None:
            w_fixed = float(theta_i_prime(i, 0.0, M))
        def w_at(z0, z1): return w_fixed
        w_label = f"w={w_fixed:.2f}"
    else:
        def w_at(z0, z1): return float(theta_i_prime(i, float(z0+z1), M))
        w_label = r"w = θ′(z₀+z₁)"

    # evaluate
    for r, z1 in enumerate(z1s):
        for c, z0 in enumerate(z0s):
            w = w_at(z0, z1)
            M["bid_q"][i, j0] = float(z0); M["bid_q"][i, j1] = float(z1)
            M["bid_p"][i, j0] = w;         M["bid_p"][i, j1] = w
            #U[r, c] = u_i_current(i, M)
            U[r, c] = eval_u_i_two_sellers(M, i, j0, j1, z0=Z0[r,c], z1=Z1[r,c],
                               price_mode="theta_prime")


    # restore
    M["bid_q"][i, j0] = q0_old; M["bid_q"][i, j1] = q1_old
    M["bid_p"][i, j0] = p0_old; M["bid_p"][i, j1] = p1_old

    # plot
    fig = plt.figure(figsize=(7, 5.5))
    ax = fig.add_subplot(111, projection="3d")
    surf = ax.plot_surface(Z0, Z1, U, rstride=1, cstride=1, linewidth=0, alpha=0.9)
    ax.set_xlabel(f"allocation from seller {j0} (z₀)")
    ax.set_ylabel(f"allocation from seller {j1} (z₁)")
    ax.set_zlabel("uᵢ")
    ax.set_title(f"Buyer {i}: utility surface in (z₀, z₁) — {w_label}")

    if with_contours:
        # add projections to the "floor" for readability
        ax.contour(Z0, Z1, U, zdir='z', offset=U.min(), levels=12, linewidths=0.8, alpha=0.7)

    if mark_current:
        a_vec, _ = a_row(i, M)
        ax.scatter([a_vec[j0]], [a_vec[j1]], [u_i_current(i, M)],
                   s=50, c="k", marker="o", label="current")
        ax.legend(loc="best")

    ax.view_init(elev=elev, azim=azim)
    fig.colorbar(surf, shrink=0.65, aspect=12, pad=0.12, label="uᵢ")
    plt.tight_layout(); plt.show()

def plot_shared_buyer_surface_split(M, i, sellers=(0,1), q_steps=60, a_steps=60,
                                    mode="theta_prime", w_fixed=None, mark_current=True):
    """
    Utility surface for a shared buyer i across two sellers (j0, j1) with *uniform price*.
    Axes: (z_total, alpha) where z0=alpha*z_total and z1=(1-alpha)*z_total.
    mode:
      - "fixed_w": use a constant w (w_fixed or θ'_i(0))
      - "theta_prime": w := θ'_i(z_total) on each grid point
    """
    import numpy as np
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D  # noqa

    j0, j1 = sellers
    qmax = float(M["Q_max"][j0] + M["Q_max"][j1])
    zs   = np.linspace(0.0, max(qmax, 1e-12), q_steps)
    alps = np.linspace(0.0, 1.0, a_steps)
    Z, A = np.meshgrid(zs, alps)
    U    = np.zeros_like(Z)

    # snapshot
    q0_old, q1_old = float(M["bid_q"][i, j0]), float(M["bid_q"][i, j1])
    p0_old, p1_old = float(M["bid_p"][i, j0]), float(M["bid_p"][i, j1])

    if mode == "fixed_w":
        if w_fixed is None:
            w_fixed = float(theta_i_prime(i, 0.0, M))
        def w_at(z): return w_fixed
    else:  # "theta_prime": price equals marginal value at z_total
        def w_at(z): return float(theta_i_prime(i, float(z), M))

    # evaluate u on grid (others held fixed)
    for r in range(a_steps):
        for c in range(q_steps):
            z_tot = float(Z[r, c]); alpha = float(A[r, c])
            z0 = alpha * z_tot
            z1 = (1.0 - alpha) * z_tot
            w  = w_at(z_tot)
            M["bid_p"][i, j0] = w;  M["bid_p"][i, j1] = w
            z0 = alpha * z_tot
            z1 = (1 - alpha) * z_tot
            M["bid_q"][i, j0] = z0; M["bid_q"][i, j1] = z1
            ##U[r, c] = u_i_current(i, M)

            U[r, c] = eval_u_i_two_sellers(M, i, j0, j1, z0=z0, z1=z1,
                               price_mode="theta_prime")


    # restore
    M["bid_q"][i, j0] = q0_old; M["bid_q"][i, j1] = q1_old
    M["bid_p"][i, j0] = p0_old; M["bid_p"][i, j1] = p1_old

    # plot
    fig = plt.figure(figsize=(6, 5))
    ax = fig.add_subplot(111, projection="3d")
    ax.plot_surface(Z, A, U, rstride=1, cstride=1, linewidth=0, alpha=0.85)
    ax.set_xlabel("total quantity z_total")
    ax.set_ylabel(r"split $\alpha$  (z$_{j0}$ = α·z,  z$_{j1}$ = (1−α)·z)")
    ax.set_zlabel("u_i")
    title = f"Buyer {i}: utility vs total & split (sellers {j0},{j1})"
    if mode == "fixed_w":
        title += f" — uniform w={w_fixed:.2f}"
    else:
        title += " — uniform w = θ′(z_total)"
    ax.set_title(title)

    if mark_current:
        a_vec, z_now = a_row(i, M)
        alpha_now = float(a_vec[j0] / max(z_now, 1e-12)) if z_now > 0 else 0.0
        u_now     = u_i_current(i, M)
        ax.scatter([z_now], [alpha_now], [u_now], s=50, c="k", marker="o", label="current")
        ax.legend(loc="best")

    plt.tight_layout(); plt.show()

def plot_prices_vs_percent(
    P: np.ndarray,
    E: np.ndarray,
    V: np.ndarray | None = None,
    B: np.ndarray | None = None,   # avg price (e.g., avg bid)
    D: np.ndarray | None = None,   # avg quantity (allocation/throughput)
    labels: list[str] | None = None,
    title: str = "Marginal value vs % multi-auction buyers",
    config: dict | None = None,    # optional: small config box
):
    """
    Plot E (marginal value) vs percent overlap, with optional:
      - V: ±sqrt(V) shading around E
      - B: average price (e.g., avg posted bid) overlay (dashed)
      - D: average quantity on a secondary y-axis (dotted)
    """
    fig, ax = plt.subplots(figsize=(7, 5))
    L, J = E.shape
    if labels is None:
        labels = [f"Seller {j}" for j in range(J)]
    x = 100.0 * P

    # Secondary y-axis for quantities if provided
    ax_q = ax.twinx() if D is not None else None

    for j in range(J):
        color = plt.cm.tab10(j % 10)

        # E_j (marginal value)
        ax.plot(x, E[:, j], color=color, lw=2, label=f"{labels[j]} – E")

        # ±√V shading
        if V is not None:
            std = np.sqrt(np.maximum(V[:, j], 0.0))
            ax.fill_between(x, E[:, j]-std, E[:, j]+std, color=color, alpha=0.18)

        # Avg price overlay (e.g., avg bid)
        if B is not None:
            ax.plot(x, B[:, j], linestyle="--", lw=1.8, color=color,
                    label=f"{labels[j]} – avg price")

        # Avg quantity on secondary axis
        if D is not None and ax_q is not None:
            ax_q.plot(x, D[:, j], linestyle=":", lw=2.0, color=color,
                      alpha=0.9, label=f"{labels[j]} – avg qty")

    ax.set_xlabel("% of buyers bidding in multiple auctions")
    ax.set_ylabel("Price")
    ax.set_title(title)
    ax.grid(True, linestyle=":", alpha=0.6)

    # Legends: combine from both axes if needed
    handles, labels_ = ax.get_legend_handles_labels()
    if ax_q is not None:
        h2, l2 = ax_q.get_legend_handles_labels()
        handles += h2; labels_ += l2
        ax_q.set_ylabel("Quantity (avg allocation)")
    ax.legend(handles, labels_, loc="best", fontsize=9)

    # Optional config box
    if config is not None:
        info_lines = []
        for key in ["I", "J", "epsilon", "base_seed", "Q_max", "reserve"]:
            if key in config:
                val = config[key]
                if isinstance(val, (list, np.ndarray)):
                    # compact summary if array-like
                    try:
                        val = np.round(np.mean(val), 3)
                    except Exception:
                        pass
                info_lines.append(f"{key}={val}")
        if info_lines:
            ax.text(1.02, 0.05, "\n".join(info_lines),
                    transform=ax.transAxes, ha="left", va="bottom",
                    fontsize=9, bbox=dict(facecolor="white", alpha=0.85, edgecolor="lightgray"))

    fig.tight_layout()
    plt.show()

def eval_u_i_two_sellers(M, i, j0, j1, z0, z1, *, price_mode="theta_prime", w_fixed=None):
    """
    Pure counterfactual utility for buyer i given requested (z0,z1) at sellers (j0,j1).
    - Freezes opponents from current M
    - Applies same price rule
    - Runs the same local PSP award (threshold + tie-split) for j0 and j1
    - Returns utility computed from *awarded* amounts
    """
    # snapshot buyer i row
    q_row = M["bid_q"][i].copy()
    p_row = M["bid_p"][i].copy()

    try:
        # price rule (unified)
        if price_mode == "theta_prime":
            w = float(theta_i_prime(i, float(z0 + z1), M))
        elif price_mode == "fixed":
            if w_fixed is None:
                raise ValueError("w_fixed must be provided for price_mode='fixed'")
            w = float(w_fixed)
        else:
            raise ValueError("unknown price_mode")

        # set the counterfactual bids just for i at j0,j1
        M["bid_q"][i, j0] = float(min(z0, M["Q_max"][j0]))
        M["bid_q"][i, j1] = float(min(z1, M["Q_max"][j1]))
        M["bid_p"][i, j0] = w
        M["bid_p"][i, j1] = w

        # run a *local* award for these two sellers only, *without* mutating global state:
        #  - build opponent ladders from frozen M for j0 and j1
        #  - compute residuals, threshold price, tie-splitting
        a0, price0 = local_award_for_seller(M, j0)  # returns awarded to each buyer; read a0[i], price0
        a1, price1 = local_award_for_seller(M, j1)

        ai = float(a0[i] + a1[i])
        pay = float(a0[i] * price0 + a1[i] * price1)
        val = float(theta_i(i, ai, M))
        return val - pay

    finally:
        # restore
        M["bid_q"][i] = q_row
        M["bid_p"][i] = p_row


# ------------------------------
# Valuation and utility surface plots
# ------------------------------

def plot_buyer_diagnostics(M: Dict, i: int, *, show_jbr: bool = True, num_points: int = 200):
    """
    One-stop diagnostic for buyer i:
      - Left: valuation θ_i(z) with current total allocation Z_cur marked.
      - Right: marginal θ'_i(z) with (Z_cur, θ'_i(Z_cur)), seller price lines p[i,j],
               and (optionally) the JBR target point (Z_hat, w_hat) from a dry-run.
      - Prints deviation metrics: max |p[i,j] - θ'_i(Z_cur)| on active sellers, spread of p’s, etc.
    """
    # ----- current snapshot totals -----
    a_vec, Z_cur = a_row(i, M)                              # allocations under current bids
    val_cur = theta_i(i, float(Z_cur), M)
    w_eff   = theta_i_prime(i, float(Z_cur), M)

    # Per-seller PSP cost (for info box)
    J = int(M["J"])
    cost_cur = sum(float(integral_P_i_j(i, j, float(a_vec[j]), M)) for j in range(J))
    util_cur = val_cur - cost_cur

    # Active sellers for this buyer
    active = (a_vec > 1e-12)
    p_row = M["bid_p"][i, :]
    p_active = p_row[active] if np.any(active) else np.array([], dtype=float)
    max_dev = float(np.max(np.abs(p_active - w_eff))) if p_active.size else 0.0
    spread  = float(np.ptp(p_active)) if p_active.size > 1 else 0.0

    # ----- optional JBR target (dry run; not applied) -----
    Z_hat, w_hat = None, None
    if show_jbr:
        q_hat, p_hat, feasible, u_hat = joint_best_response_plan(i, M)
        if feasible:
            Z_hat = float(np.sum(q_hat))
            w_hat = float(p_hat[0]) if len(p_hat) else 0.0

    # ----- curves -----
    zmax = float(M["qbar"][i])
    Zs = np.linspace(0.0, max(zmax, 1e-12), num_points)
    vals  = np.array([theta_i(i, float(z), M)       for z in Zs], dtype=float)
    mvals = np.array([theta_i_prime(i, float(z), M) for z in Zs], dtype=float)

    # ----- plotting -----
    fig, axes = plt.subplots(1, 2, figsize=(10, 4))
    axV, axM = axes

    # Valuation
    axV.plot(Zs, vals, label=r"$\theta_i(z)$")
    axV.axvline(float(Z_cur), linestyle="--", linewidth=0.8)
    axV.scatter([Z_cur], [val_cur], zorder=5, label="current")
    if show_jbr and (Z_hat is not None):
        axV.axvline(Z_hat, linestyle=":", linewidth=0.8)
        axV.scatter([Z_hat], [theta_i(i, Z_hat, M)], marker="x", zorder=6, label="JBR target")

    axV.set_xlabel("Total quantity z")
    axV.set_ylabel(r"$\theta_i(z)$")
    axV.set_title(f"Buyer {i}: valuation")
    axV.legend(loc="best")
    axV.set_xlim(0.0, zmax * 1.1 if zmax > 0 else 1.0)

    # Marginal
    axM.plot(Zs, mvals, label=r"$\theta'_i(z)$")
    axM.scatter([Z_cur], [w_eff], zorder=5, label="current (z, θ')")
    if show_jbr and (w_hat is not None):
        axM.scatter([Z_hat], [w_hat], marker="x", zorder=6, label="JBR (ẑ, ŵ)")

    # Seller price lines for this buyer
    for j in range(J):
        pj = float(p_row[j])
        axM.axhline(pj, linestyle="--", linewidth=0.8, alpha=0.5)
        # annotate on the right margin
        axM.text(zmax * 1.01 if zmax > 0 else 0.01, pj, f" p[{j}]={pj:.2f}",
                 va="center", fontsize=8)

    axM.set_xlabel("Total quantity z")
    axM.set_ylabel("Marginal value / Price")
    axM.set_title(f"Buyer {i}: marginal vs. prices")
    axM.legend(loc="best")
    ylim_max = max(
        (mvals.max() if mvals.size else 1.0),
        (float(np.max(p_row)) if J > 0 else 0.0)
    ) * 1.1
    if ylim_max <= 0: ylim_max = 1.0
    axM.set_xlim(0.0, zmax * 1.1 if zmax > 0 else 1.0)
    axM.set_ylim(0.0, ylim_max)

    # Info box (right)
    txt = [
        f"Z_cur={Z_cur:.3f}",
        f"θ'(Z_cur)={w_eff:.3f}",
        f"val={val_cur:.3f}, cost={cost_cur:.3f}, util={util_cur:.3f}",
        f"active sellers={int(np.sum(active))}",
        f"max|p-θ'| (active)={max_dev:.3e}",
        f"spread(p_active)={spread:.3e}",
    ]
    if show_jbr and (Z_hat is not None):
        txt += [f"JBR: ẑ={Z_hat:.3f}, ŵ={w_hat:.3f}"]
    axM.text(0.98, 0.02, "\n".join(txt), ha="right", va="bottom",
             transform=axM.transAxes, fontsize=9,
             bbox=dict(boxstyle="round,pad=0.3", alpha=0.1))

    fig.suptitle(f"Buyer {i}: valuation & marginal diagnostics", y=1.02)
    fig.tight_layout()
    plt.show()

def plot_utility_surface(M: Dict, i: int, j: int, q_steps: int = 50, p_steps: int = 50):
    """Plot u_i under PSP cost while varying (q,p) at seller j.
    """
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D # noqa: F401 (needed for 3D projection)

    zs = np.linspace(0.0, float(M["Q_max"][j]), q_steps)
    w_max = theta_i_prime(i, 0.0, M)
    ws = np.linspace(0.0, max(w_max, 1e-12), p_steps)
    Z, W = np.meshgrid(zs, ws)
    U = np.zeros_like(Z)

    # snapshot original cell and compute
    q_old = float(M["bid_q"][i, j]); p_old = float(M["bid_p"][i, j])
    for r in range(p_steps):
      for c in range(q_steps):
        M["bid_q"][i, j] = float(Z[r, c])
        M["bid_p"][i, j] = float(W[r, c])
        U[r, c] = u_i_current(i, M)
    M["bid_q"][i, j] = q_old
    M["bid_p"][i, j] = p_old

    print(f"Utility range (buyer {i}, seller {j}): {U.min():.6f} .. {U.max():.6f}")
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_wireframe(Z, W, U, rstride=1, cstride=1)
    ax.set_xlabel('quantity z to seller j')
    ax.set_ylabel('price w to seller j')
    ax.set_zlabel('u_i (PSP)')
    ax.set_title(f'Utility Surface (buyer {i}, seller {j})')
    plt.tight_layout(); plt.show()

# ------------------------------
# Connectivity plots
# ------------------------------

def plot_connectivity(M: Dict, *, title: Optional[str] = None, show_labels: bool = True):
    """
    Visualize market connectivity M["adj"] (I x J boolean) with:
      - Left: matrix scatter (buyer index vs seller index)
      - Right: bipartite layout (buyers at y=0, sellers at y=1, edges as line segments)
    """
    if "adj" not in M:
        raise ValueError("M['adj'] not found. Pass an (I x J) boolean adjacency matrix in make_market_multi(...).")

    adj = np.asarray(M["adj"], dtype=bool)
    I, J = adj.shape
    ii, jj = np.nonzero(adj)  # edge endpoints (buyer i, seller j)

    fig, axes = plt.subplots(1, 2, figsize=(10, 4))
    axL, axR = axes

    # --- Left: matrix scatter view ---
    axL.scatter(jj, ii, s=25, marker='s')
    axL.set_xlabel("seller j")
    axL.set_ylabel("buyer i")
    axL.set_xlim(-0.5, J - 0.5)
    axL.set_ylim(I - 0.5, -0.5)  # buyer 0 at top
    axL.set_xticks(range(J))
    axL.set_yticks(range(I))
    axL.set_title("Adjacency (matrix scatter)")
    axL.grid(True, linestyle=":", linewidth=0.5, alpha=0.4)

    # --- Right: bipartite scatter view ---
    # buyers at y=0, sellers at y=1
    x_b = np.arange(I); y_b = np.zeros(I)
    x_s = np.arange(J); y_s = np.ones(J)

    axR.scatter(x_b, y_b, s=40, label="buyers")
    axR.scatter(x_s, y_s, s=60, marker="^", label="sellers")

    # Build edge segments efficiently
    if ii.size:
        segments = [((x_b[i], 0.0), (x_s[j], 1.0)) for i, j in zip(ii, jj)]
        lc = LineCollection(segments, linewidths=0.8, alpha=0.35)
        axR.add_collection(lc)

    if show_labels:
        for i in range(I):
            axR.text(x_b[i], -0.06, f"b{i}", ha="center", va="top", fontsize=8)
        for j in range(J):
            axR.text(x_s[j], 1.06, f"s{j}", ha="center", va="bottom", fontsize=8)

    axR.set_xlim(-0.5, max(I, J) - 0.5)
    axR.set_ylim(-0.4, 1.4)
    axR.set_yticks([0, 1]); axR.set_yticklabels(["buyers", "sellers"])
    axR.set_xticks([])
    axR.set_title("Adjacency (bipartite scatter)")
    axR.legend(loc="upper right", fontsize=8, frameon=False)

    if title:
        fig.suptitle(title, y=1.02)
    fig.tight_layout()
    plt.show()


# =====================================================
# Engine
# =====================================================

# ------------------------------
# Engine run loop
# ------------------------------

def run(M: Dict, steps: int = 1000, verbose: bool = False, *, idle_event_limit: int | None = None):
    """Run the engine.

    If M["instant_post"] is True, only BUYER_COMPUTE events will be present
    (POST_BID is unused). If M["deterministic_sched"] is True, scheduling uses
    deterministic times (no jitter), improving reproducibility.

    break_on_convergence: stop when no POST_BID has applied for
      idle_event_limit events and there are no pending POST_BIDs.
    idle_event_limit: default = I (set at runtime if None).
    """
    if idle_event_limit is None:
        idle_event_limit = int(M["I"]) if M["I"] else 4

    for it in range(steps):
        item = pop(M)
        if item is None:
            break
        t, _, etype, payload = item
        M["t"] = float(t)
        if etype == BUYER_COMPUTE:
            (i,) = payload
            handle_buyer_compute(M, int(i), verbose=verbose)
            # count toward idle if nothing applied elsewhere
            M["events_since_apply"] = M.get("events_since_apply", 0) + 1
        elif etype == POST_BID:
            i, j, q, p, gen = payload
            handle_post_bid(M, int(i), int(j), float(q), float(p), int(gen), verbose=verbose)
            # events_since_apply reset inside handler on apply
        else:
            raise RuntimeError(f"Unknown event type {etype}")

        # Convergence check: no pending posts and long idle since last apply
        pend = M.get("pending_posts", 0)
        if pend == 0 and M.get("events_since_apply", 0) >= idle_event_limit:
            if verbose:
                print(f"Converged: no price updates for {M['events_since_apply']} events; pending_posts=0")
            break

    return it

# =====================================================
# 1) Sanity (Price-Ladder)
# =====================================================

def seed_bids(M, bids):
    """
    bids: iterable of (i, j, q, p)
    """
    for (i, j, q, p) in bids:
        M["bid_q"][i, j] = float(q)
        M["bid_p"][i, j] = float(p)

def print_awards(M, title="Awards"):
    print(f"\n--- {title} ---")
    for j in range(int(M["J"])):
        a_j, pstar_j = local_award_for_seller(M, j)
        winners = np.where(a_j > 1e-12)[0].tolist()
        print(f"Seller {j}: p*={pstar_j:.3f}  winners={winners}  awards={np.round(a_j,3)}")

def make_adj_for_ladder(I, J, *, ell: int, j: int, i: int, k: int,
                        extra_edges: list[tuple[int,int]] | None = None,
                        reserve_buyer_idx: int | None = None) -> np.ndarray:
    """
    Build an adjacency matrix (I x J) that satisfies the lemma's connectivity:
      - i bids on j and ℓ
      - k bids on ℓ but NOT on j
    All other entries are False unless you pass extra_edges.

    Args
    ----
    I, J : ints
    ell, j : seller indices (0..J-1) with ell != j
    i, k   : buyer indices (0..I-1) with i != k
    extra_edges : optional list of (buyer, seller) edges to also enable
    reserve_buyer_idx : if you use a virtual reserve bidder (e.g., 0), we can
                        avoid touching its row here (no effect on correctness).

    Returns
    -------
    adj : (I, J) boolean ndarray
    """
    assert 0 <= ell < J and 0 <= j < J and ell != j, "ell and j must be distinct seller indices"
    assert 0 <= i   < I and 0 <= k < I and i   != k, "i and k must be distinct buyer indices"

    adj = np.zeros((I, J), dtype=bool)

    # Core lemma edges
    adj[i, ell] = True
    adj[i, j]   = True
    adj[k, ell] = True
    # NOTE: intentionally do NOT connect (k, j)

    # Optional extras
    if extra_edges:
        for (bi, sj) in extra_edges:
            if reserve_buyer_idx is not None and bi == reserve_buyer_idx:
                # leave reserve buyer handling to your enable_reserve_buyer0()
                continue
            assert 0 <= bi < I and 0 <= sj < J
            adj[bi, sj] = True

    return adj

def run_sanity_ladder():
    """
    Construction:
      - Two sellers: j=1 (Q=8), ℓ=0 (Q=15).
      - Buyer i (idx 0): bids high on BOTH sellers (q=8 on j & ℓ at price 40).
      - Buyer k (idx 1): bids only on ℓ (q=2 at price 4).
      - Buyer z2 (idx 2): bids only on ℓ (q=6 at very low price 1).
      - Buyer z1 (idx 3): inactive (kept for indexing symmetry).

    Outcomes:
      - Seller j (1): winners {i}; p*_j ≈ 40 (filled by i alone).
      - Seller ℓ (0): winners {i, k, z2}; p*_ℓ ≈ 1 (marginal tier is low).
      - Ladder tuple (ℓ,k,j,i) should satisfy p*_ℓ < p_k < p*_j ≤ p_i.
    """
    from math import isclose
    I=4; J=2
    #adj = np.ones((I, J), dtype=bool)
    ell, j = 0, 1     # two sellers
    i, k   = 2, 3     # pick any two distinct buyers

    adj = make_adj_for_ladder(I=I, J=J, ell=ell, j=j, i=i, k=k)
    M = make_market_multi(I=I, J=J, Q_max=[15.0, 8.0], epsilon=2.5, adj=adj, price_tol=5e-3)

    # (i=0) high price on both sellers; (k=1) only ℓ; (z2=2) only ℓ; (z1=3) inactive
    seed_bids(M, [
        (0, 1, 8.0, 40.0),  # i on j
        (0, 0, 8.0, 40.0),  # i on ℓ
        (1, 0, 2.0,  4.0),  # k on ℓ
        (2, 0, 6.0,  1.0),  # z2 on ℓ
        #(3, 1, 2.0, 1.2)  # z1 inactive to keep p*_j high; uncomment to test variants
    ])
    set_stable_order(M, seed_order=42)
    schedule_all_buyers_stable(M, t0=0.0)

    it = run(M, steps=2000, verbose=True)

    print_awards(M, "Sanity — awards before ladder check")

    # Verify awards & p*
    a_l, p_l = local_award_for_seller(M, 0)  # ℓ
    a_j, p_j = local_award_for_seller(M, 1)  # j
    assert isclose(p_j, 40, rel_tol=0, abs_tol=1e-12), f"p*_j should be 40, got {p_j}"
    assert isclose(p_l,  1.0, rel_tol=0, abs_tol=1e-12), f"p*_ℓ should be 1, got {p_l}"

    # Ladder check
    lad = LadderDict(M)
    df = lad.check_all_price_ladders(t=M["t"])

    if df.empty:
        print("No ladder tuples found.")
    else:
        with pd.option_context("display.max_rows", None, "display.width", 100):
            print("\nLADDER TUPLES:")
            print(df.round(3).to_string(index=False))
            plot_connectivity(M, title="Market connectivity", show_labels=True)
            plot_buyer_diagnostics(M, i=2, show_jbr=True)
            plot_shared_buyer_surface_split(M, 2, sellers=(0,1), mode="theta_prime")
            plot_shared_buyer_surface_z0z1(M, 2, sellers=(0,1), mode="theta_prime")

    lad.print_final_ladder_report(M["t"])

# =====================================================
# 2) Experiment 1 (BFS on Price-Ladder)
# =====================================================
def reset_market_for_new_adj(M: Dict,
                             adj: np.ndarray,
                             *,
                             seed_bids: int | None = None,
                             seed_sched: int | None = None,
                             jitter: float = 0.0) -> None:
    I, J = int(M["I"]), int(M["J"])

    adj = np.asarray(adj, bool)
    M["adj"] = adj

    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)
    if seed_bids is not None:
        randomize_bids(M, seed=seed_bids)
        #fair_bids(M)
    else:
        print("Warning: Initial bids non-deterministic!")

    M["pq"].clear()
    M["seq"] = 0
    M["t"] = 0.0
    M["gen"].fill(0)
    M["pending_posts"] = 0
    M["events_since_apply"] = 0

    # 4) Deterministic scheduling, if desired
    if seed_sched is not None:
        M["rng"] = np.random.default_rng(seed_sched)
    else:
        print("Warning: Non-deterministic scheduling!")
    M["jitter"] = float(jitter)


def run_experiment(I, J, percents, Q_max, epsilon, reserve, steps, base_seed, jitter):
    # Fix primitives once
    Q = np.full(J, float(Q_max)) if np.isscalar(Q_max) else np.asarray(Q_max, float)
    R = np.full(J, float(reserve)) if np.isscalar(reserve) else np.asarray(reserve, float)

    M = make_market_multi(I, J, Q_max=Q, epsilon=epsilon, reserve=R,
                          seed=base_seed, adj=np.ones((I, J), dtype=bool))

    P = np.asarray(percents, float)
    E = np.zeros((len(P), J)); V = np.zeros((len(P), J))
    B = np.zeros((len(P), J)); T = np.zeros((len(P), J))
    history_buyers = pd.DataFrame(columns=['interval','Seller','Buyer','q_i','p_i','a_i','z_i','p_marg','v_i','u_i','c_i','diff'])
    history_sellers = pd.DataFrame()

    seed_bids  = base_seed + 17    # same bids across levels
    seed_sched0 = base_seed + 313  # deterministic schedule per level

    for li, pm in enumerate(P):
        # new adjacency for this level (percent-specific but reproducible)
        rng_adj = np.random.default_rng(base_seed + 1009*li)
        adj = make_membership_adj(I, J, pm, rng=rng_adj)

        # reuse the same market: swap adj + reset state/bids
        reset_market_for_new_adj(M, adj, seed_bids=seed_bids,
                                 seed_sched=seed_sched0 + li, jitter=0.0)

        #M["instant_post"] = True            # apply updates on compute, no POST_BID
        #M["deterministic_sched"] = True     # schedule computes at t0+i, no jitter

        set_stable_order(M, seed_order=42)
        schedule_all_buyers_stable(M, t0=0.0)
        #schedule_all_buyers(M, t0=0.0)

        it = run(M, steps=2000, verbose=False)

        lad = LadderDict(M)
        df = lad.check_all_price_ladders(t=pm)
        if df.empty:
            print("No ladder tuples found — reasons logged.")
        else:
            with pd.option_context("display.max_rows", None, "display.width", 100):
                print("\nLADDER TUPLES:")
                print(df.round(3).to_string(index=False))
        lad.print_final_ladder_report(pm)

        plot_shared_buyer_surface_split(M, 6, sellers=(0,1), mode="theta_prime")
        plot_shared_buyer_surface_z0z1(M, 6, sellers=(0,1), mode="theta_prime")
        #schedule_all_buyers(M)

        metrics = compute_market_metrics(M)
        #print_round_from_metrics(metrics)
        rep = market_report_from(metrics, level="seller").rename(columns={"seller":"Seller"})
        rep["interval"] = pm

        # 1) Global classification (one row per buyer)
        df_bstat = classify_buyers(M)
        n_zero_alloc_pos_bid = int(df_bstat["zero_alloc_pos_bid"].sum())
        n_zero_bid_no_gain   = int(df_bstat["zero_bid_no_gain"].sum())

        # 2) Per-seller loser counts
        losers_per_seller = per_seller_outbid_losers(M)

        rep["losers"] = losers_per_seller  # per seller
        print_df(rep)
        # Add global counts (same value on each seller row for convenience)
        rep["zero_alloc_pos_bid_total"] = n_zero_alloc_pos_bid
        rep["zero_bid_no_gain_total"]   = n_zero_bid_no_gain

        history_buyers  = record_market_snapshot_from(metrics, interval=pm,
                                                      market_history=history_buyers)

        history_sellers = pd.concat([history_sellers, rep], ignore_index=True)

        # 4) (Optional) store buyer-level flags in history_buyers
        df_bstat["interval"] = pm
        history_buyers = pd.concat([history_buyers, df_bstat], ignore_index=True)

        # metrics & reports
        E[li] = rep["E_j"].to_numpy()
        V[li] = rep["V_j"].to_numpy()
        B[li] = rep["avg_bid"].to_numpy()
        T[li] = per_seller_thresholds(M)


    return M, P, E, V, B, T, history_buyers, history_sellers


def experiment1():
    I, J = 8, 2
    percents = [x / 100.0 for x in range(0, 101, 10)]  # 0 → 100
    base_seed=20405008
    Q_max=[60.0, 40.0]
    epsilon=2.5
    jitter=0.0

    M, P, E, V, B, T, H_buyers, H_sellers = run_experiment(
        I=I,
        J=J,
        percents=percents,
        Q_max=Q_max,
        epsilon=epsilon,
        reserve=[0.0, 0.0],
        steps=1500,
        base_seed=base_seed,
        jitter=jitter
    )
    seeds = record_seeds(
        base_seed=base_seed,
        I=I, J=J, percents=percents,
        verbose=True
    )

    tbl_E = pd.DataFrame({
        f"Seller {j}": [f"{E[li, j]:.3f} ± {np.sqrt(V[li, j]):.3f}" for li in range(len(P))]
        for j in range(J)
    }, index=[f"{int(100*p)}%" for p in P])

    tbl_B = pd.DataFrame({
        f"Seller {j}": [f"{B[li, j]:.3f}" for li in range(len(P))]
        for j in range(J)
    }, index=[f"{int(100*p)}%" for p in P])

    print_df(tbl_E, header="E_j ± √V_j by percent (mean ± std)")
    print_df(tbl_B, header="Average Bid Price by percent (avg_p_bid)")

    tbl_res = pd.DataFrame({
        f"Seller {j}": [
            f"{E[li, j]:.3f} ± {np.sqrt(V[li, j]):.3f}  |  {B[li, j]:.3f}"
            for li in range(len(P))
        ]
        for j in range(J)
    }, index=[f"{int(100*p)}%" for p in P])

    print_df(tbl_res, header="E_j ± √V_j  |  avg marginal value (mean ± std  | avg bid price)")

    plot_prices_vs_percent(P, E, V, B, T,
                           labels=[f"Seller {j}" for j in range(J)],
                           config={"epsilon": epsilon,
                                    "base_seed": base_seed,
                                    "Q_max": Q_max,
                                    "jitter": jitter,
                                    "#buyers": I}
                           )


# -----------------
# Demo (minimal)
# -----------------
if __name__ == "__main__":
    run_sanity_ladder()
    #experiment1()

