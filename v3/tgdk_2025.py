# -*- coding: utf-8 -*-
"""TGDK-2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p8lEpTqehrRwrN98TvWNvMOkJvKSXQZO
"""

from __future__ import annotations

import numpy as np
import pandas as pd
from typing import Dict, Tuple, List, Optional

# ------------------------------
# Event types
# ------------------------------
BUYER_COMPUTE = 1
POST_BID = 2

# ------------------------------
# Market construction
# ------------------------------

def make_market_multi(I: int,
                      J: int,
                      Q_max: float | np.ndarray = 100.0,
                      epsilon: float = 5.0,
                      reserve: float | np.ndarray = 0.0,
                      budget_range=(1000.0, 1000.0),
                      q_range=(10.0, 60.0),
                      kappa_range=(1.0, 3.5),
                      seed: int = 12345,
                      jitter: float = 0.01,
                      price_tol: float = 5e-3,
                      adj: Optional[np.ndarray] = None) -> Dict:
    """Create a multi-seller PSP market state as flat arrays.

    Buyer arrays (len I): b, qbar, kappa, gen
    Seller arrays (len J): Q_max, reserve
    Bid arrays (I×J): bid_q, bid_p
    """
    rng = np.random.default_rng(seed)
    b = rng.uniform(*budget_range, size=I)
    qbar = rng.uniform(*q_range, size=I)
    kappa = rng.uniform(*kappa_range, size=I)

    Q_max = np.full(J, float(Q_max)) if np.isscalar(Q_max) else np.asarray(Q_max, dtype=float)
    assert Q_max.shape == (J,)
    reserve = np.full(J, float(reserve)) if np.isscalar(reserve) else np.asarray(reserve, dtype=float)
    assert reserve.shape == (J,)

    bid_q = np.zeros((I, J), dtype=float)
    bid_p = np.zeros((I, J), dtype=float)

    M = {
        "I": I,
        "J": J,
        "b": np.ascontiguousarray(b, dtype=float),
        "qbar": np.ascontiguousarray(qbar, dtype=float),
        "kappa": np.ascontiguousarray(kappa, dtype=float),
        "Q_max": np.ascontiguousarray(Q_max, dtype=float),
        "reserve": np.ascontiguousarray(reserve, dtype=float),
        "bid_q": np.ascontiguousarray(bid_q, dtype=float),
        "bid_p": np.ascontiguousarray(bid_p, dtype=float),
        "adj": np.ascontiguousarray(adj, dtype=bool),
        "epsilon": float(epsilon),
        # async engine
        "pq": [],
        "seq": 0,
        "t": 0.0,
        "jitter": float(jitter),
        "rng": rng,
        # buyer generations (staleness guard for POST_BID)
        "gen": np.zeros(I, dtype=np.int64),
        # tolerances
        "tol": 1e-12,
        # convergence bookkeeping
        "pending_posts": 0,
        "events_since_apply": 0,
        "price_tol": float(price_tol),
        "seller_converged": np.ones(J, dtype=bool),
    }

    return M

# ------------------------------
# Buyer valuation and derivatives
# ------------------------------

def theta_i(i: int, z: float, M: Dict) -> float:
    """θ_i(z) = κ_i * qbar_i * m − 0.5 * κ_i * m^2, with m = min(z, qbar_i)."""
    m = min(z, float(M["qbar"][i]))
    k = float(M["kappa"][i])
    return k * float(M["qbar"][i]) * m - 0.5 * k * m * m


def theta_i_prime(i: int, z: float, M: Dict) -> float:
    """θ'_i(z) = κ_i * (qbar_i − z) for z ≤ qbar_i; 0 beyond."""
    q = float(M["qbar"][i])
    k = float(M["kappa"][i])
    return k * (q - z) if z < q else 0.0

# ------------------------------
# Seller-side primitives (columnwise)
# ------------------------------

def _others_mask(i: int, I: int) -> np.ndarray:
    m = np.ones(I, dtype=bool); m[i] = False; return m

def Q_i_j(i: int, j: int, p: float, M: Dict) -> float:
    """Q_i^j(p): remaining capacity at seller j after removing opponents with price > p."""
    mask = _others_mask(i, M["I"]) ; qcol = M["bid_q"][mask, j] ; pcol = M["bid_p"][mask, j]
    rem = M["Q_max"][j] - float(np.sum(qcol[pcol > p]))
    return rem if rem > 0.0 else 0.0

def Qbar_i_j(i: int, j: int, p: float, M: Dict) -> float:
    """Q̄_i^j(p): remaining capacity at seller j after removing opponents with price ≥ p."""
    mask = _others_mask(i, M["I"]) ; qcol = M["bid_q"][mask, j] ; pcol = M["bid_p"][mask, j]
    rem = M["Q_max"][j] - float(np.sum(qcol[pcol >= p]))
    return rem if rem > 0.0 else 0.0

def P_i_j(i: int, j: int, z: float, M: Dict) -> float:
    """Price density P_i^j(z) = inf{ y ≥ 0 : Q_i^j(y) ≥ z }. Evaluate across candidate prices."""
    others = _others_mask(i, M["I"]) ; cand = np.unique(np.concatenate(([0.0], M["bid_p"][others, j])))
    for y in cand:
        if Q_i_j(i, j, float(y), M) >= z:
            return float(y)
    return float("inf")

def integral_P_i_j(i: int, j: int, a: float, M: Dict, N: int = 100) -> float:
    if a <= 0.0: return 0.0
    zs = np.linspace(0.0, a, N + 1)
    Ps = np.array([P_i_j(i, j, float(zk), M) for zk in zs])
    dz = a / N
    return float(np.trapezoid(Ps, dx=dz))

# ------------------------------
# Seller-side helpers
# ------------------------------

def buyers_on_j(M: Dict, j: int):
    qcol = M["bid_q"][:, j]
    active = [qcol > 0.0 + M["tol"]]
    active &= M["adj"][:, j]
    return np.nonzero(active)[0]

def seller_shell_1hop(M: Dict, j: int):
    """1-hop seller shell: sellers ℓ that share ≥1 active buyer with seller j."""
    shell = set()
    buyers = buyers_on_j(M, j)
    if not buyers.any():
        return shell
    bid_q = M["bid_q"]
    for i in buyers:
        sellers_i = np.nonzero(bid_q[i, :] > 0.0 + M["tol"])[0]
        for ell in sellers_i:
            if ell == j:
                continue
            shell.add(ell)
    return shell

def pstar_j(M: Dict, j: int) -> float:
    I = M["I"]
    Qj = M["Q_max"][j]
    qcol = M["bid_q"][:, j]
    pcol = M["bid_p"][:, j]
    idx = np.nonzero(qcol > 0.0 + M["tol"])[0]
    if idx.size == 0:
        return 0.0
    bids = [(i, qcol[i], pcol[i]) for i in idx]
    bids.sort(key=lambda t: t[2], reverse=True)
    cum = 0.0
    for (i, q, p) in bids:
        if cum + q >= Qj - M["tol"]:
            return p
        cum += q
    return 0.0

def winners_on_j(M: Dict, j: int):
    """Buyers who fill up to Q_max[j] at current bids."""
    Qj = M["Q_max"][j]
    qcol = M["bid_q"][:, j]
    pcol = M["bid_p"][:, j]
    idx = np.nonzero(qcol > M["tol"])[0]
    if idx.size == 0:
        return []
    bids = [(i, qcol[i], pcol[i]) for i in idx]
    bids.sort(key=lambda t: t[2], reverse=True)
    winners = []
    cum = 0.0
    for i, q, p in bids:
        if cum + M["tol"] >= Qj:
            break
        take = min(q, Qj - cum)
        if take > 0.0:
            winners.append(i)
            cum += take
    return winners

# ------------------------------
# Current allocation/cost/utility for buyer i (snapshot based)
# ------------------------------

def a_row(i: int, M: Dict) -> Tuple[np.ndarray, float]:
    """Return per-seller allocations a_ij for current bids, and their total."""
    J = M["J"]
    a = np.zeros(J, dtype=float)
    for j in range(J):
        q, p = float(M["bid_q"][i, j]), float(M["bid_p"][i, j])
        a[j] = min(q, Qbar_i_j(i, j, p, M))
    return a, float(np.sum(a))

def cost_row(i: int, a: np.ndarray, M: Dict) -> float:
    J = M["J"]; return float(sum(integral_P_i_j(i, j, float(a[j]), M) for j in range(J)))

def u_i_current(i: int, M: Dict) -> float:
    a, atot = a_row(i, M)
    cost = cost_row(i, a, M)
    return theta_i(i, atot, M) - cost

def active_sellers_for_i(M: Dict, i: int):
    qrow = M["bid_q"][i, :]
    mask = qrow > 0.0 + M["tol"]
    if "adj" in M:
        mask &= M["adj"][i, :].astype(bool)
    return np.nonzero(mask)[0]

# ------------------------------
# Joint best response
# ------------------------------

def build_ladders(i: int, M: Dict) -> Dict:
    """
    Build per-seller price ladders of opponents for buyer i:
      - per_seller[j]: dict with fields
          'p'    : opponents' posted prices at seller j (ascending, filtered by adjacency)
          'q'    : aligned opponents' quantities
          'pref' : prefix sums of q (pref[t] = sum_{<t} q_sorted)
          'suf'  : suffix sums of q (suf[t]  = sum_{>=t} q_sorted)
      - steps: sorted global union of {0} ∪ {opponent prices across all sellers} ∪ {w_max}
      - w_max: θ'_i(0)
    """
    I, J = int(M["I"]), int(M["J"])
    others = np.ones(I, dtype=bool); others[i] = False
    has_adj = M.get("adj") is not None

    per_seller = []
    all_steps = [0.0]
    for j in range(J):
        if has_adj:
            opp_ok = M["adj"][others, j]
        else:
            opp_ok = np.ones(I - 1, dtype=bool)
        pcol = np.asarray(M["bid_p"][others, j][opp_ok], dtype=float)
        qcol = np.asarray(M["bid_q"][others, j][opp_ok], dtype=float)
        if pcol.size:
            idx = np.argsort(pcol, kind="mergesort")
            p_sorted = pcol[idx]
            q_sorted = qcol[idx]
            n = p_sorted.size
            pref = np.empty(n + 1, dtype=float); pref[0] = 0.0
            for t in range(n): pref[t + 1] = pref[t] + float(q_sorted[t])
            suf  = np.empty(n + 1, dtype=float); suf[n] = 0.0
            for t in range(n - 1, -1, -1): suf[t] = suf[t + 1] + float(q_sorted[t])
            per_seller.append({"p": p_sorted, "q": q_sorted, "pref": pref, "suf": suf})
            all_steps.extend(np.unique(p_sorted).tolist())
        else:
            per_seller.append({"p": np.array([], float),
                               "q": np.array([], float),
                               "pref": np.array([0.0], float),
                               "suf":  np.array([0.0], float)})
    w_max = float(theta_i_prime(i, 0.0, M))
    steps = np.unique(np.concatenate([np.asarray(all_steps, float), np.array([w_max], float)]))
    return {"per_seller": per_seller, "steps": steps, "w_max": w_max}


def _avail_lt_price(i: int, j: int, y: float, M: Dict, ladders: Dict) -> float:
    L = ladders["per_seller"][j]
    p = L["p"]; suf = L["suf"]
    if p.size == 0:
        return M["Q_max"][j]
    idx = np.searchsorted(p, y, side="right")
    taken = suf[idx]
    rem = M["Q_max"][j] - taken
    return max(0.0, rem)

def _avail_at_price(j: int, y: float, ladders: Dict) -> float:
    L = ladders["per_seller"][j]
    p = L["p"]; pref = L["pref"]
    if p.size == 0:
        return 0.0
    l = np.searchsorted(p, y, side="left")
    r = np.searchsorted(p, y, side="right")
    return pref[r] - pref[l]

def _count_bids_with_equal_price(j: int, y: float, ladders: Dict) -> int:
    L = ladders["per_seller"][j]
    p = L["p"]
    if p.size == 0:
        return 0
    l = np.searchsorted(p, y, side="left")
    r = np.searchsorted(p, y, side="right")
    return r - l

def avail_at_bprice(i: int, y: float, M: Dict, ladders: Dict) -> np.ndarray:
    #return avail_at_bprice_qjc(i, y, M, ladders)
    return avail_at_bprice_fair(i, y, M, ladders)

def avail_at_bprice_fair(i: int, y: float, M: Dict, ladders: Dict) -> np.ndarray:
    """
    Caps z_caps[j] available to buyer i at price boundary yy under a tie policy,
        split residual among equals by COUNT (approx QJC)
    """
    J = int(M["J"]); caps = np.zeros(J, dtype=float)
    for j in range(J):
        rem = _avail_lt_price(i, j, y, M, ladders)
        # Split residual among equal-price group (opponents at y plus buyer i)
        eq_cnt = 1 + _count_bids_with_equal_price(j, y, ladders)
        caps[j] = (rem / float(eq_cnt)) if rem > 0.0 else 0.0
        # We cannot determine a quantity-proportional cap without q_ij.
        # Return the open cap; we'll enforce QJC proportionally after we pick q_row.
    return caps

def avail_at_bprice_qjc(i: int, y: float, M: Dict, ladders: Dict) -> np.ndarray:
    """
    For each seller j: let rem be the capacity left after serving bids with p > y.
    If buyer i participates in the y-tie on seller j with quantity q_i^j (proposed or current),
    allocate to i the proportional share:  rem * q_i^j / (q_i^j + sum_{k!=i, p_k^j=y} q_k^j).
    """
    J = M["J"]
    tol = M["tol"]
    caps = np.zeros(J, float)
    for j in range(J):
        rem = _avail_lt_price(i, j, y, M, ladders)  # capacity after strictly higher prices
        qi = M["bid_q"][i, j]
        if rem <= 0.0 or qi <= 0.0:
            caps[j] = 0.0
            continue
        eq_mask = np.abs(M["bid_p"][:, j] - y) <= tol
        # sum of others at price y
        sum_others = np.sum(M["bid_q"][eq_mask, j]) - (M["bid_q"][i, j] if eq_mask[i] else 0.0)
        denom = qi + sum_others
        caps[j] = rem * qi / denom if denom > 0.0 else 0.0
    return caps

def sup_G_i_multi(i: int, M: Dict, ladders: Dict) -> Tuple[float, np.ndarray, float, Dict]:
    tol = M["tol"]
    steps = ladders["steps"]  # sorted breakpoints y_0 < y_1 < ...
    w_max = ladders["w_max"]

    # 1) Look for an interior solution on each open interval (y_k, y_{k+1}).
    #    Availability is constant on (y_k, y_{k+1}), so evaluate at y_k (strict '>').
    for k in range(len(steps) - 1):
        y_left, y_right = steps[k], steps[k + 1]
        if y_right <= y_left + tol:
            continue
        caps = avail_at_bprice(i, y_left, M, ladders)
        Z = np.sum(caps)
        w_imp = theta_i_prime(i, Z, M)
        if (w_imp > y_left + tol) and (w_imp < y_right - tol):
            z_star = min(M["qbar"][i], Z)
            return w_imp, caps, z_star, {"type": "interior"}

    # 2) No interior: take the largest left boundary y_k with theta'(Z_k) >= y_k.
    k_star = 0
    for k in range(len(steps) - 1):
        yk = steps[k]
        Zk = avail_at_bprice(i, yk, M, ladders).sum()
        if theta_i_prime(i, Zk, M) >= yk - tol:
            k_star = k

    y_lower = steps[k_star] # left boundary of that interval
    lower_caps = avail_at_bprice(i, y_lower, M, ladders)
    Z_low = np.sum(caps)
    C_low = y_lower*Z_low
    print("[boundary] Lower boundary cost: ", C_low)

    y_upper = steps[min(k_star + 1, len(steps) - 1)]  # right boundary of that interval
    upper_caps = avail_at_bprice(i, y_upper, M, ladders)
    Z_up = np.sum(caps)
    C_up = y_upper*Z_up
    print("[boundary] Upper boundary cost: ", C_up)

    if C_low >= C_up:
      y_star = y_lower
      z_star = min(M["qbar"][i], Z_low)
    else:
      y_star = y_upper
      z_star = min(M["qbar"][i], Z_up)

    return y_star, caps, z_star, {"type": "boundary", "y": y_star}

def _min_cost_split(i, M: Dict, z_star, caps, ladders, y_ref):
    J = M["J"]
    q = np.zeros(J, dtype=float)
    if z_star <= 0:
        return q
    segments = []
    for j in range(J):
        if caps[j] > 0:
            segments += _per_seller_segments_upto(i, j, y_ref, M, ladders)
    segments.sort(key=lambda t: t[0])
    rem = z_star
    for price, length, j in segments:
        if rem <= 0:
            break
        room = caps[j] - q[j]
        if room <= 0:
            continue
        take = min(rem, room, length)
        if take > 0:
            q[j] += take
            rem  -= take
    return np.minimum(q, caps)

def _per_seller_segments_upto(i, j, y_ref, M: Dict, ladders):
    if not M["adj"][i, j]:
        return []
    L = ladders["per_seller"][j]
    p_sorted = L["p"]
    if p_sorted.size:
        steps = np.unique(np.concatenate(([0.0], p_sorted[p_sorted <= y_ref])))
    else:
        steps = np.array([0.0])
    segs = []
    prev = 0.0
    for y in steps:
        rem = _avail_lt_price(i, j, y, M, ladders)   # remaining capacity with strict '>'
        delta = rem - prev
        if delta > 0:
            segs.append((y, delta, j))
        prev = rem
    return segs

def apply_budget_policy(i, M: Dict, q_row, base_cost):
    b = M["b"][i]
    def util(qv, c):
        return theta_i(i, np.sum(qv), M) - c
    feasible = (base_cost <= b + M["tol"])
    return q_row, base_cost, util(q_row, base_cost), feasible

def compute_t_i_multi(i, M: Dict, w_star, caps, z_star, meta, ladders):
    y_ref = meta.get("y", w_star) if isinstance(meta, dict) else w_star
    q_row = _min_cost_split(i, M, z_star, np.asarray(caps), ladders, y_ref)
    p_row = np.full(M["J"], w_star)
    base_cost = cost_row(i, q_row, M)
    q_row, cost_new, u_new, feasible = apply_budget_policy(i, M, q_row, base_cost)
    return q_row, p_row, cost_new, u_new, feasible

def joint_best_response_plan(i: int, M: Dict) -> Tuple[np.ndarray, np.ndarray, bool, float]:
    ladders = build_ladders(i, M)
    w_star, caps, z_star, meta = sup_G_i_multi(
        i, M, ladders)
    q_row, p_row, cost, u_new, feasible = compute_t_i_multi(
        i, M, w_star, caps, z_star, meta, ladders)
    return q_row, p_row, feasible, u_new


# =====================================================
# Network
# =====================================================
import heapq

# ------------------------------
# Priority queue helpers
# ------------------------------

def push(M: Dict, t: float, etype: int, payload: Tuple):
    M["seq"] += 1
    heapq.heappush(M["pq"], (float(t), int(M["seq"]), int(etype), payload))

def pop(M: Dict):
    return heapq.heappop(M["pq"]) if M["pq"] else None

def schedule_all_buyers(M: Dict, t0: float = 0.0):
    det = M["deterministic_sched"]
    perm = M["perm"]
    rng = M["rng"]
    for i in range(M["I"]):
        if det:
            t_i = t0 + float(i)
        else:
            t_i = t0 + float(rng.random() * M.get("jitter", 0.0))
        push(M, t_i, BUYER_COMPUTE, (i,))

def schedule_all_buyers_stable(M: dict, seed_order: int, t0: float = 0.0):
    I = int(M["I"])
    M["perm"] = np.random.default_rng(seed_order).permutation(I).astype(int)
    pos = np.empty(I, dtype=int)
    pos[M["perm"]] = np.arange(I)
    M["perm_pos"] = pos
    M["jitter"] = 0.0
    M["pq"].clear()
    for k, i in enumerate(M["perm"]):
        push(M, t0 + float(k), BUYER_COMPUTE, (int(i),))


# ------------------------------
# Events
# ------------------------------

def handle_buyer_compute(M: Dict, i: int, verbose: bool = False, debug: bool = False):
    t0 = M["t"]
    u0 = u_i_current(i, M)
    q_row, p_row, feasible, u1 = joint_best_response_plan(i, M)
    if "deterministic_sched" in M and M["deterministic_sched"]:
        push(M, t0 + 1.0, BUYER_COMPUTE, (i,))
    elif "perm_pos" in M:
        slot = 1e-9 * int(M["perm_pos"][i])
        push(M, float(np.floor(t0)) + 1.0 + slot, BUYER_COMPUTE, (i,))
    else:
        push(M, t0 + 1.0 + M["rng"].random() * M["jitter"], BUYER_COMPUTE, (i,))
    tol = M["tol"]
    if (not feasible) or (u1 <= u0 + tol):
        if verbose:
            print(f"[event] BUYER_COMPUTE i={i}: no update (feasible={feasible}, Δu={u1-u0:.6f})")
        return False
    dq = np.abs(M["bid_q"][i] - q_row)
    dp = np.abs(M["bid_p"][i] - p_row)
    bid_move = max(dq.max(initial=0.0), dp.max(initial=0.0))
    if bid_move <= tol:
        if verbose:
            print(f"[event] BUYER_COMPUTE i={i}: within tol (Δu={u1-u0:.6f}, move={bid_move:.3e})")
        return False
    M["gen"][i] += 1
    gen = int(M["gen"][i])
    J = M["J"]
    if "instant_post" in M and M["instant_post"]:
        changed = False
        for j in range(J):
            if (dq[j] > tol) or (dp[j] > tol):
                M["bid_q"][i, j] = q_row[j]
                M["bid_p"][i, j] = p_row[j]
                changed = True
        if changed:
            M["events_since_apply"] = 0
            if verbose:
                print(f"[event] BUYER_COMPUTE i={i}: applied (gen={gen}, Δu={u1-u0:.6f}, move={bid_move:.3e})")
        else:
            if verbose:
                print(f"[event] BUYER_COMPUTE i={i}: nothing to apply after tol check (move={bid_move:.3e})")
        return changed
    num_posts = 0
    for j in range(J):
        if (dq[j] > tol) or (dp[j] > tol):
            num_posts += 1
            t_post = t0 + M["rng"].random() * M["jitter"]
            push(M, t_post, POST_BID, (i, j, q_row[j], p_row[j], gen))
    if num_posts:
        M["pending_posts"] += num_posts
        if verbose:
            print(f"[event] BUYER_COMPUTE i={i}: accepted (gen={gen}), posts={num_posts}, Δu={u1-u0:.6f}, move={bid_move:.3e}")
        return True
    if verbose:
        print(f"[event] BUYER_COMPUTE i={i}: nothing to post (move={bid_move:.3e})")
    return False


def handle_post_bid(M: Dict, i: int, j: int, q: float, p: float, gen: int, verbose: bool = False, debug: bool = False):
    if not M["adj"][i, j]:
        if M.get("pending_posts", 0) > 0:
            M["pending_posts"] -= 1
        if debug:
            print(f"[event] POST_BID blocked (no edge): i={i}, j={j}")
        return False
    if (M["gen"][i] != gen):
        if verbose:
            print(f"[event] POST_BID stale drop: i={i}, j={j}, gen={gen} (current gen={M['gen'][i]})")
        return False
    # fresh -> apply
    M["bid_q"][i,j] = q; M["bid_p"][i,j] = p
    if M.get("pending_posts", 0) > 0:
        M["pending_posts"] -= 1
    M["events_since_apply"] = 0
    if verbose:
        print(f"[event] POST_BID applied: i={i}, j={j}, (q,p)=({q:.4f},{p:.4f})")
    return True


# =====================================================
# Ladder Verification
# =====================================================
from dataclasses import dataclass, field

@dataclass
class LadderResult:

    _ladder_impossible: set = field(default_factory=set)

def make_ladder_report(M: Dict) -> LadderResult:
      _ladder_impossible = set()

      df = check_all_price_ladders(M, lad=_ladder_impossible, t=M["t"])
      if df.empty:
        print("No ladder tuples found.")
      else:
        with pd.option_context("display.max_rows", None, "display.width", 100):
            print("\nLADDER TUPLES:")
            print(df.round(3).to_string(index=False))
      print_final_ladder_report(M, df)
      return df

def _ladder_precheck(M: Dict, j: int):
    if not M["seller_converged"][j]:
        return False, f"seller {j} not converged (shell not saturated)"
    pj_star = pstar_j(M, j)
    if pj_star <= 0.0:
        return False, f"seller {j} undersubscribed / no marginal tier (p*_j=0)"
    shell = seller_shell_1hop(M, j)
    if not shell:
        return False, f"no 1-hop neighbors with shared active buyers for seller {j}"
    if all(not M["seller_converged"][ell] for ell in shell):
        return False, f"no converged neighbors with a marginal tier around seller {j}"
    Wj = winners_on_j(M, j)
    if not Wj:
        return False, f"no winners on seller {j} (empty W^j)"
    has_valid_neighbor = any(M["seller_converged"][ell]
                             and pstar_j(M, ell) > 0.0 for ell in shell)
    if not has_valid_neighbor:
        return False, f"no converged neighbors with a marginal tier around seller {j}"
    return True, ""

def _price_ladder_checks(M: Dict, j: int, lad: set(), hops: int=1):
    ok, reason = _ladder_precheck(M, j)
    if not ok:
        print(f"[ladder] seller {j}: skipped — {reason}")
        return pd.DataFrame({"__no_ladder_reason__": [reason]})

    pj_star = pstar_j(M, j)
    shell = seller_shell_1hop(M, j)
    Wj = set(winners_on_j(M, j))
    tol = M["price_tol"]
    rows = []
    bid_q = M["bid_q"]
    bid_p = M["bid_p"]

    for i in Wj:
        pi_star = float(bid_p[i, j])
        sellers_i = set(active_sellers_for_i(M, i))
        for ell in (sellers_i - {j}) & set(shell):
            if not M["seller_converged"][ell]:
                continue
            p_ell_star = pstar_j(M, ell)
            if p_ell_star >= pj_star - tol:
                pair = (j, ell)
                if pair not in lad:
                    print(f"[ladder] seller {j}: cannot build vs {ell} "
                          f"(p*_ell={p_ell_star:.3f} ≥ p*_j={pj_star:.3f})")
                    lad.add(pair)
                continue
            if p_ell_star <= 0.0 + tol:
                continue

            winners_ell = winners_on_j(M, ell)
            for k in winners_ell:
                if k in Wj:
                    continue
                qk_ell = bid_q[k, ell]
                if qk_ell <= 0.0 + M["tol"]:
                    continue
                pk_ell = bid_p[k, ell]
                ok_left  = (p_ell_star <= pk_ell + tol)
                ok_mid   = (pk_ell <  pj_star - tol)
                ok_right = (pj_star  <= pi_star + tol)
                rows.append({
                    "ell": ell,
                    "k": k,
                    "j": j,
                    "i": i,
                    "p_ell*": p_ell_star,
                    "p_k*": pk_ell,
                    "p_j*": pj_star,
                    "p_i*": pi_star,
                    "ok_left": ok_left,
                    "ok_mid": ok_mid,
                    "ok_right": ok_right,
                })

    df = pd.DataFrame(rows)
    if df.empty:
        print(f"[ladder] seller {j}: no valid (ell,k,i) tuples")
        return pd.DataFrame({"__no_ladder_reason__": [f"no valid (ell,k,i) tuples found around seller {j}"]})
    df["all_ok"] = df["ok_left"] & df["ok_mid"] & df["ok_right"]
    return df

def check_all_price_ladders(M: Dict, lad: set(), t: int=0.0, hops: int=1):
    frames = []
    reasons = []
    J = M["J"]
    for j in range(J):
        out = _price_ladder_checks(M, j, lad, hops=hops)
        if "__no_ladder_reason__" in out.columns:
            reasons.append((j, out["__no_ladder_reason__"].iloc[0]))
        else:
            out = out.copy()
            out["dt"] = t
            frames.append(out)

    df = pd.concat(frames, ignore_index=True) if frames else pd.DataFrame()
    for sid, msg in reasons:
        print(f"[ladder] seller {sid}: {msg}")
    if df.empty:
        print("[ladder] No ladder tuples found.")
        return df
    bad = df[~df["all_ok"]]
    good = df[df["all_ok"]]

    if not good.empty:
        margin_left  = (good["p_k*"] - good["p_ell*"]).min()
        margin_mid   = (good["p_j*"] - good["p_k*"]).min()
        margin_right = (good["p_i*"] - good["p_j*"]).min()
        n_pairs = good[["ell", "j"]].drop_duplicates().shape[0]
        print(f"\n[ladder] t={t:.2f} — PRICE LADDER HOLDS on {len(good)} tuples "
              f"across {n_pairs} (j,ℓ) pairs\n"
              f"tightest margins:\n"
              f" (pk−pℓ*): {margin_left:.3g}, (p*j−pk): {margin_mid:.3g}, (pi−p*j): {margin_right:.3g}")
    if not bad.empty:
        print("\n[ladder] WARNING: violations detected (pℓ* ≤ pk < p*j ≤ pi):")
        show = bad.copy()
        for c in ["p_ell*", "p_k*", "p_j*", "p_i*"]:
            show[c] = show[c].round(3)
        print(show.to_string(index=False))
    return df

def _ladder_reason_empty(M: Dict):
    J = M["J"]
    zeros = []
    for j in range(J):
        if pstar_j(M, j) == 0.0:
            zeros.append(j)
    if zeros:
        ids = ", ".join(str(x) for x in zeros)
        return f"No ladder: undersubscribed sellers with p* = 0 (sellers: {ids})."
    return ("No ladder: graph has only trivial shells "
            "(each seller shares ≤1 buyer, so (ℓ,k,j,i) cannot form).")

def print_final_ladder_report(M: Dict, out: pd.DataFrame, t_now=0.0, hops=1):
    if out.empty:
        print(f"[Final Ladder] {_ladder_reason_empty(M)}")
        return
    if out["all_ok"].all():
        print(f"\n[Final Ladder] Monotone price ladder verified at t={t_now:.2f} "
              "(pℓ ≤ pk < pj ≤ pi).")
        with pd.option_context("display.max_rows", None, "display.width", 100):
            view = out[["ell","k","j","i","p_ell*","p_k*","p_j*","p_i*"]].drop_duplicates().round(3)
            print(view.to_string(index=False))
    else:
        bad = out[out["all_ok"] == False]
        print("\n[Final Ladder] WARNING: violations remain.")
        with pd.option_context("display.max_rows", None, "display.width", 100):
            print(bad.to_string(index=False))



# =====================================================
# Reporting
# =====================================================

@dataclass
class MarketMetrics:
    # core arrays
    a_mat: np.ndarray           # (I,J) allocations a_ij
    buyer_alloc: np.ndarray     # (I,)
    buyer_value: np.ndarray     # (I,)
    buyer_util: np.ndarray      # (I,)
    buyer_marg: np.ndarray      # (I,)
    bid_p: np.ndarray           # (I,J)
    bid_q: np.ndarray           # (I,J)
    adj:   np.ndarray           # (I,J) bool

    # quick seller totals
    alloc_j: np.ndarray         # (J,)
    revenue_j: np.ndarray       # (J,)
    Q_max: np.ndarray           # (J,)
    E_j: np.ndarray             # (J,)
    V_j: np.ndarray             # (J,)
    p_star_j: np.ndarray        # (J,)


def compute_market_metrics(M: Dict) -> MarketMetrics:
    I, J = M["I"], M["J"]
    adj   = np.asarray(M["adj"], bool)
    bid_q = np.asarray(M.get("bid_q", np.zeros((I, J))), float)
    bid_p = np.asarray(M.get("bid_p", np.zeros((I, J))), float)

    a_mat       = np.zeros((I, J), float)
    buyer_alloc = np.zeros(I, float)
    buyer_value = np.zeros(I, float)
    buyer_util  = np.zeros(I, float)
    buyer_marg  = np.zeros(I, float)

    # One pass over buyers to build allocations and utilities at current bids
    for i in range(I):
        a_vec, z = a_row(i, M)                  # current allocation per seller and total
        a_mat[i, :]    = a_vec
        buyer_alloc[i] = z
        val_i          = theta_i(i, z, M)
        buyer_value[i] = val_i
        cost_i         = cost_row(i, a_vec, M)
        buyer_util[i]  = val_i - cost_i
        buyer_marg[i]  = theta_i_prime(i, z, M) if z > 0.0 else 0.0

    alloc_j   = a_mat.sum(axis=0)
    revenue_j = np.zeros(J, float)
    E_j       = np.zeros(J, float)  # allocation-weighted average posted bid
    V_j       = np.zeros(J, float)  # allocation-weighted variance of posted bids
    p_star_j  = np.zeros(J, float)

    for j in range(J):
        A = alloc_j[j]
        if A <= 0.0:
            continue

        # Seller revenue at current PSP pricing via your integral (unchanged)
        for i in range(I):
            a_ij = a_mat[i, j]
            if a_ij > 0.0:
                revenue_j[j] += integral_P_i_j(i, j, a_ij, M)

        # Allocation-weighted average and variance of posted bid prices on seller j
        a_col = a_mat[:, j]
        p_col = bid_p[:, j]
        Ej = (a_col * p_col).sum() / A
        E_j[j] = Ej
        V_j[j] = ((a_col * (p_col - Ej) ** 2).sum()) / A

        p_star_j[j] = pstar_j(M, j)

    Q_max = M["Q_max"]

    return MarketMetrics(
        a_mat=a_mat, buyer_alloc=buyer_alloc, buyer_value=buyer_value,
        buyer_util=buyer_util, buyer_marg=buyer_marg, bid_p=bid_p,
        bid_q=bid_q, adj=adj, alloc_j=alloc_j, revenue_j=revenue_j, Q_max=Q_max,
        E_j=E_j, V_j=V_j, p_star_j=p_star_j,
    )

def market_report_from(metrics: MarketMetrics) -> pd.DataFrame:
    a_mat       = metrics.a_mat
    buyer_alloc = metrics.buyer_alloc
    buyer_value = metrics.buyer_value
    buyer_util  = metrics.buyer_util
    buyer_marg  = metrics.buyer_marg
    alloc_j     = metrics.alloc_j
    revenue_j   = metrics.revenue_j
    E_j         = metrics.E_j
    V_j         = metrics.V_j
    Q_max       = metrics.Q_max
    p_star_j    = metrics.p_star_j

    I, J = a_mat.shape

    # Attribute buyer totals to sellers proportionally to a_ij / z_i
    value_j = np.zeros(J, float)
    util_j  = np.zeros(J, float)
    mask_pos = buyer_alloc > 0
    if np.any(mask_pos):
        W = np.zeros_like(a_mat)
        # rows of W sum to 1 over sellers where a_ij>0
        W[mask_pos, :] = (a_mat[mask_pos, :].T / buyer_alloc[mask_pos]).T
        value_j = W.T @ buyer_value
        util_j  = W.T @ buyer_util

    df = pd.DataFrame({
        "seller":   np.arange(J),
        "alloc":    alloc_j,
        "value":    value_j,
        "util":     util_j,
        "revenue":  revenue_j,
        "E_j":      E_j,
        "V_j":      V_j,
        "Q_max":    Q_max,
        "p_star_j": p_star_j,
    }).round(3)

    return df


def record_market_snapshot_from(metrics: MarketMetrics,
                                interval: float,
                                market_history: pd.DataFrame) -> pd.DataFrame:
    I, J = metrics.a_mat.shape
    rows = []
    for i in buyers_iter(M, include_reserve=False):
        z_i    = float(metrics.buyer_alloc[i])
        v_i    = float(metrics.buyer_value[i])
        u_i    = float(metrics.buyer_util[i])
        p_marg = float(metrics.buyer_marg[i])
        for j in np.where(metrics.adj[i])[0]:
            rows.append({
                "interval": interval,
                "Seller":   int(j),
                "Buyer":    int(i),
                "q_i":      float(metrics.bid_q[i, j]),
                "p_i":      float(metrics.bid_p[i, j]),
                "a_i":      float(metrics.a_mat[i, j]),
                "z_i":      z_i,
                "p_marg":   p_marg if z_i > 0.0 else 0.0,
                "v_i":      v_i,
                "u_i":      u_i,
                "c_i":      float(v_i - u_i),
                "diff":     0,
            })
    if rows:
        snap = pd.DataFrame(rows)
        return pd.concat([market_history, snap], ignore_index=True)
    return market_history

def print_round_from_metrics(metrics: MarketMetrics,
                            round_decimals: int = 3,
                            full_index: bool = True,
                            header: str | None = None) -> pd.DataFrame:
    a_mat = metrics.a_mat
    bid_q = metrics.bid_q
    bid_p = metrics.bid_p
    adj = metrics.adj
    I, J = a_mat.shape
    base_idx = list(range(I)) if full_index else sorted(np.where(metrics.buyer_alloc> -1)[0].tolist())
    # ---------------- Buyer Totals ----------------
    totals = pd.DataFrame({
            "Buyer": np.array(base_idx, dtype=int),
            "z_i": metrics.buyer_alloc,
            "p_marg": metrics.buyer_marg,
            "v_i": metrics.buyer_value,
            "u_i": metrics.buyer_util,
            "c_i": metrics.buyer_value - metrics.buyer_util,
        })
    totals = totals.set_index("Buyer").reindex(base_idx).reset_index()
    for c in totals.select_dtypes(include="number").columns:
        if c != "Buyer":
            totals[c] = totals[c].round(round_decimals)
    totals.columns = pd.MultiIndex.from_product([["Buyer Totals"], totals.columns])
    blocks = [totals]
    # ---------------- Seller blocks ----------------
    for j in range(J):
        sub = pd.DataFrame({
                "Buyer": np.array(base_idx, dtype=int),
                "q_i": bid_q[:, j],
                "p_i": bid_p[:, j],
                "a_i": a_mat[:, j],
            }).set_index("Buyer").reindex(base_idx)
        no_edge = pd.Series([not bool(adj[b, j]) if (0 <= b < adj.shape[0]) else True for b in base_idx], index=base_idx)
        mask_blank = no_edge
        def fmt(series: pd.Series) -> pd.Series:
            s = series.copy()
            s = s.where(~mask_blank, np.nan)
            s = s.where(s.isna(), s.round(round_decimals))
            return s.astype(object).where(~s.isna(), "--")

        out = pd.DataFrame(index=sub.index)
        out["Buyer"] = out.index.astype(int)
        out["q_i"] = fmt(sub["q_i"])
        out["p_i"] = fmt(sub["p_i"])
        out["a_i"] = fmt(sub["a_i"])

        out = out.reset_index(drop=True)
        out.columns = pd.MultiIndex.from_product([[f"Seller {j}"], out.columns])
        blocks.append(out)

    wide = pd.concat(blocks, axis=1, join="outer")
    print_df(wide, header=(header or "Market snapshot"), index=False)
    return wide

def print_df(df: pd.DataFrame,
          header: Optional[str] = None,
          index: bool = False,
          max_rows: Optional[int] = 200,
          max_cols: Optional[int] = None,
          width: int = 120,
          round_decimals: Optional[int] = None) -> None:
    out = df.copy()
    if round_decimals is not None:
        num_cols = out.select_dtypes(include="number").columns
        out[num_cols] = out[num_cols].round(round_decimals)

    with pd.option_context(
        "display.max_rows", max_rows,
        "display.max_columns", max_cols,
        "display.width", width,
        "display.expand_frame_repr", False,
    ):
        text = out.to_string(index=index)
    if header:
        print(f"\n{header}\n{text}")
    else:
        print(f"\n{text}")


def classify_buyers(M: dict, tol: float = 1e-12) -> pd.DataFrame:
    """
    Classify buyers at convergence, respecting adjacency:
      - has_pos_bid: any positive bid on a connected edge
      - zero_alloc_pos_bid: z_i == 0 but posted positive qty on some connected edge
      - zero_bid: no positive bids on any connected edge
      - zero_bid_no_gain: zero_bid AND JBR would also pick zero (on connected edges)
      - deg_i: number of connected sellers
    """
    I, J = int(M["I"]), int(M["J"])
    adj = M["adj"]

    rows = []
    for i in range(I):
        # Connected sellers for i
        conn = adj[i, :]
        deg_i = int(np.count_nonzero(conn))

        # Allocation snapshot (a_row already yields zeros for non-bids; we’ll still mask)
        a_vec, z_i = a_row(i, M)
        a_conn = np.where(conn, a_vec, 0.0)
        z_i_conn = float(np.sum(a_conn))

        # Positive bids only on connected edges
        bid_q_i = np.asarray(M["bid_q"][i, :], float)
        has_pos_bid = bool(np.any(bid_q_i[conn] > tol))
        zero_bid = (not has_pos_bid)  # only considering connected edges
        zero_alloc_pos_bid = (z_i_conn <= tol) and has_pos_bid

        # For zero-bid buyers, check if JBR would still choose zero *given connected edges*
        zero_bid_no_gain = False
        if zero_bid and deg_i > 0:
            ladders = build_ladders(i, M)  # build_ladders already honors adjacency
            _, _, z_star, _ = sup_G_i_multi(i, M, ladders)
            zero_bid_no_gain = (float(z_star) <= tol)
        elif zero_bid and deg_i == 0:
            # No connected sellers: treat as structurally out (not a failure to bid)
            zero_bid_no_gain = True

        rows.append({
            "buyer": i,
            "deg_i": deg_i,
            "z_i": float(z_i_conn),
            "has_pos_bid": has_pos_bid,
            "zero_alloc_pos_bid": zero_alloc_pos_bid,
            "zero_bid": zero_bid,
            "zero_bid_no_gain": zero_bid_no_gain,
        })
    return pd.DataFrame(rows)

def per_seller_outbid_losers(M: dict, tol: float = 1e-12) -> np.ndarray:
    """
    Per seller j: count buyers who posted positive qty on (i,j) AND are connected to j,
    but received zero allocation at j.
    """
    I, J = int(M["I"]), int(M["J"])
    adj = M["adj"]
    counts = np.zeros(J, dtype=int)
    for i in range(I):
        a_vec, _ = a_row(i, M)
        for j in range(J):
            if not adj[i, j]:
                continue
            if (M["bid_q"][i, j] > tol) and (a_vec[j] <= tol):
                counts[j] += 1
    return counts

def eval_u_i_two_sellers(M, i, j0, j1, z0, z1):
    q_row = M["bid_q"][i].copy()
    p_row = M["bid_p"][i].copy()
    try:
        w = theta_i_prime(i, z0 + z1, M)
        M["bid_q"][i, j0] = min(z0, M["Q_max"][j0])
        M["bid_q"][i, j1] = min(z1, M["Q_max"][j1])
        M["bid_p"][i, j0] = w
        M["bid_p"][i, j1] = w
        a_vec, z = a_row(i, M)
        p0 = pstar_j(M, j0)
        p1 = pstar_j(M, j1)
        pay = a_vec[j0] * p0 + a_vec[j1] * p1
        val = theta_i(i, z, M)
        return val - pay
    finally:
        M["bid_q"][i] = q_row
        M["bid_p"][i] = p_row

# =====================================================
# Helpers
# =====================================================

# ------------------------------
# Initialization helpers
# ------------------------------

def randomize_bids(M: Dict, seed: int ) -> None:
    I, J = M["I"], M["J"]
    # Clear any existing bids
    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)
    adj = M["adj"]

    def buyer_rng(i: int) -> np.random.Generator:
        # Independent per-buyer stream → stable w.r.t. other randomness
        return np.random.default_rng(np.int64(seed) + np.int64(i) * 1_000_003)

    for i in range(I):
        rng_i = buyer_rng(i)
        z_total = rng_i.uniform(0.0, M["qbar"][i])
        if z_total <= M["tol"]:
            continue
        idxs = np.flatnonzero(adj[i])
        if idxs.size == 0:
            continue

        share = z_total / idxs.size
        p_uniform = theta_i_prime(i, z_total, M)  # same price across auctions
        for j in idxs:
            M["bid_q"][i, j] = share
            M["bid_p"][i, j] = p_uniform
    return

def make_membership_adj(I: int, J: int,
                        percent_multi: float,
                        rng: Optional[np.random.Generator]) -> np.ndarray:
    adj = np.zeros((I, J), dtype=bool)
    for i in range(I):
        K = 2 if rng.random() < percent_multi else 1
        idx = rng.choice(J, size=K, replace=False)
        adj[i, idx] = True
    return adj

def record_seeds(base_seed: int,
                 *,
                 I: int,
                 J: int,
                 percents,
                 seed_model: int | None = None,
                 seed_bids: int | None = None,
                 seed_adj: int | None = None,
                 seed_sched: int | None = None,
                 verbose: bool = True) -> dict:

    seed_model = base_seed if seed_model is None else seed_model
    seed_bids  = base_seed + 17 if seed_bids is None else seed_bids
    seed_sched = base_seed + 313 if seed_sched is None else seed_sched
    seed_adj0  = base_seed if seed_adj is None else seed_adj

    seeds = {
        "I": I,
        "J": J,
        "percents": list(map(float, percents)),
        "base_seed": base_seed,
        "seed_model": seed_model,
        "seed_bids": seed_bids,
        "seed_sched": seed_sched,
        "seed_adj_base": seed_adj0,
        "seed_adj_per_level": {
            f"{int(p*100)}%": seed_adj0 + 1009 * li
            for li, p in enumerate(percents)
        }
    }
    if verbose:
        print("=== Random Seed Configuration ===")
        for k, v in seeds.items():
            if isinstance(v, dict):
                continue
            print(f"{k:18s}: {v}")
        print("Adjacency per level:")
        for label, sval in seeds["seed_adj_per_level"].items():
            print(f"  {label:>6s} → {sval}")
        print("=================================\n")
    return seeds

def fair_bids(M: dict, seed: int | None = None, mode: str = "equal") -> None:
    I, J = M["I"], M["J"]
    adj  = M["adj"]
    Qmax = M["Q_max"]
    qbar = M["qbar"]
    bvec = M["b"]
    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)
    for i in range(I):
        idxs = np.flatnonzero(adj[i])
        if idxs.size == 0:
            continue
        cap = Qmax[idxs].sum()
        if cap <= 0:
            continue
        z = min(qbar[i], cap)
        if z <= 0:
            continue
        if mode == "capacity":
            w = Qmax[idxs]
            s = w.sum()
            shares = (w / s) if s > 0 else np.full(idxs.size, 1.0 / idxs.size)
        else:
            shares = np.full(idxs.size, 1.0 / idxs.size)
        q_row = z * shares
        p_uni = theta_i_prime(i, float(z), M)

        q_full = np.zeros(J)
        q_full[idxs] = q_row
        cost0 = cost_row(i, q_full, M)
        # Scale bids to stay within budget if necessary
        if cost0 > bvec[i]:
            lo, hi = 0.0, 1.0
            for _ in range(40):
                mid = 0.5 * (lo + hi)
                if cost_row(i, mid * q_full, M) <= bvec[i]:
                    lo = mid
                else:
                    hi = mid
            q_full *= lo
            q_row = q_full[idxs]
            z = q_row.sum()
            p_uni = theta_i_prime(i, float(z), M)
        M["bid_q"][i, idxs] = q_row
        M["bid_p"][i, idxs] = p_uni


# =====================================================
# Plotting
# =====================================================
import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from mpl_toolkits.mplot3d import Axes3D  # noqa

def plot_buyer_diagnostics(M: Dict, i: int, *, show_jbr: bool = True, num_points: int = 200):
    # snapshot
    a_vec, z_cur = a_row(i, M)
    val_cur = theta_i(i, float(z_cur), M)
    w_cur  = theta_i_prime(i, float(z_cur), M)

    J = M["J"]
    p_row = M["bid_p"][i]
    cost_cur = sum(integral_P_i_j(i, j, float(a_vec[j]), M) for j in range(J))
    util_cur = val_cur - cost_cur

    # curves
    zmax = float(M["qbar"][i])
    Zs = np.linspace(0.0, max(zmax, 1e-12), num_points)
    vals  = np.array([theta_i(i, float(z), M)       for z in Zs])
    mvals = np.array([theta_i_prime(i, float(z), M) for z in Zs])

    Z_hat, w_hat = None, None
    if show_jbr:
        q_hat, p_hat, feasible, _ = joint_best_response_plan(i, M)
        if feasible:
            Z_hat = float(np.sum(q_hat))
            w_hat = float(p_hat[0]) if len(p_hat) else None

    # plotting
    fig, (axV, axM) = plt.subplots(1, 2, figsize=(10, 4))

    # valuation
    axV.plot(Zs, vals)
    axV.axvline(z_cur, linestyle="--", linewidth=0.8)
    axV.scatter([z_cur], [val_cur], zorder=5)
    if show_jbr and (Z_hat is not None):
        axV.axvline(Z_hat, linestyle=":", linewidth=0.8)
        axV.scatter([Z_hat], [theta_i(i, Z_hat, M)], marker="x", zorder=6)
    axV.set_xlabel("Total quantity z")
    axV.set_ylabel(r"$\theta_i(z)$")
    axV.set_title(f"Buyer {i}: valuation")
    axV.set_xlim(0.0, zmax * 1.1 if zmax > 0 else 1.0)

    # marginal & prices
    axM.plot(Zs, mvals)
    axM.scatter([z_cur], [w_cur], zorder=5)
    if show_jbr and (Z_hat is not None) and (w_hat is not None):
        axM.scatter([Z_hat], [w_hat], marker="x", zorder=6)
    for j in range(J):
        pj = float(p_row[j])
        axM.axhline(pj, linestyle="--", linewidth=0.8, alpha=0.5)
        axM.text(zmax * 1.01 if zmax > 0 else 0.01, pj, f"p[{j}]={pj:.2f}", va="center", fontsize=8)
    axM.set_xlabel("Total quantity z")
    axM.set_ylabel("Marginal value / Price")
    axM.set_title(f"Buyer {i}: marginal vs. prices")
    ylim_max = max(mvals.max() if mvals.size else 1.0, float(np.max(p_row)) if J else 0.0) * 1.1
    axM.set_xlim(0.0, zmax * 1.1 if zmax > 0 else 1.0)
    axM.set_ylim(0.0, ylim_max if ylim_max > 0 else 1.0)

    # info box
    info = [
        f"z={z_cur:.3f}",
        f"θ'={w_cur:.3f}",
        f"val={val_cur:.3f}",
        f"cost={cost_cur:.3f}",
        f"util={util_cur:.3f}",
    ]
    if show_jbr and (Z_hat is not None) and (w_hat is not None):
        info.append(f"joint-best-response ẑ={Z_hat:.3f}, ŵ={w_hat:.3f}")
    axM.text(0.98, 0.02, "\n".join(info), ha="right", va="bottom",
             transform=axM.transAxes, fontsize=9,
             bbox=dict(boxstyle="round,pad=0.3", alpha=0.1))

    fig.suptitle(f"Buyer {i}: valuation & marginal diagnostics", y=1.02)
    fig.tight_layout()
    plt.show()

def plot_connectivity(M: Dict, *, title: Optional[str] = None, show_labels: bool = True):
    adj = M["adj"]
    I, J = adj.shape
    ii, jj = np.nonzero(adj)
    fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))
    axL, axR = axes
    axL.scatter(jj, ii, s=36, marker='s')
    axL.set_xlabel("seller j")
    axL.set_ylabel("buyer i")
    axL.set_xlim(-0.5, J - 0.5)
    axL.set_ylim(I - 0.5, -0.5)  # buyer 0 at top
    axL.set_xticks(range(J))
    axL.set_yticks(range(I))
    axL.set_title("Adjacency (matrix view)")
    axL.grid(True, linestyle=":", linewidth=0.6, alpha=0.4)
    x_b = np.arange(I)
    y_b = np.zeros(I)
    x_s = np.arange(J)
    y_s = np.ones(J)

    buyers_sc = axR.scatter(x_b, y_b, s=52, label="buyers")
    sellers_sc = axR.scatter(x_s, y_s, s=72, marker="^", label="sellers")

    if ii.size:
        segments = [((x_b[i], 0.0), (x_s[j], 1.0)) for i, j in zip(ii, jj)]
        lc = LineCollection(segments, linewidths=1.0, alpha=0.35)
        axR.add_collection(lc)

    if show_labels:
        for i in range(I):
            axR.text(x_b[i], -0.08, f"b{i}", ha="center", va="top", fontsize=8)
        for j in range(J):
            axR.text(x_s[j], 1.08, f"s{j}", ha="center", va="bottom", fontsize=8)
    xmax = max(I, J) - 0.5
    axR.set_xlim(-0.5, xmax)
    axR.set_ylim(-0.4, 1.4)
    axR.set_yticks([0, 1])
    axR.set_yticklabels(["buyers", "sellers"])
    axR.set_xticks([])
    axR.set_title("Adjacency (bipartite view)")
    axR.legend(loc="upper right", fontsize=8, frameon=False)
    if title:
        fig.suptitle(title, y=0.95)
    fig.tight_layout()
    plt.show()

def plot_seller_price_ladder(M, j):
    qcol = M["bid_q"][:, j]
    pcol = M["bid_p"][:, j]
    bids = [(i, float(qcol[i]), float(pcol[i])) for i in range(M["I"]) if qcol[i] > 0.0]
    if not bids:
        print(f"Seller {j}: no bids.")
        return

    bids.sort(key=lambda t: t[2], reverse=True)
    Qj = float(M["Q_max"][j])
    cum, p_star = 0.0, 0.0
    xs, heights, labels = [], [], []
    for idx, (i, q, p) in enumerate(bids):
        xs.append(idx)
        heights.append(q)
        labels.append(f"B{i}{p:.2g}")
        if p_star == 0.0 and cum + q >= Qj:
            p_star = p
        cum += q

    fig, ax = plt.subplots(figsize=(7.5, 3.6))
    ax.bar(xs, heights, alpha=0.85)
    ax.set_xticks(xs)
    ax.set_xticklabels(labels)
    ax.set_ylabel("requested q_i^j")
    ax.set_xlabel("buyers (price under label)")
    ax2 = ax.twinx()
    ax2.step([x - 0.5 for x in xs] + [xs[-1] + 0.5], np.cumsum([0.0] + heights), where='post', linewidth=1.25)
    ax2.set_ylabel("cumulative quantity")

    ax.axhline(Qj, linestyle='--', linewidth=1, label=f"Q_j={Qj:g}")
    ax2.axhline(Qj, linestyle='--', linewidth=1)
    if p_star > 0.0:
        ax.text(0.02, 0.95, f"p*={p_star:.3g}", transform=ax.transAxes, ha='left', va='top', bbox=dict(boxstyle='round', alpha=0.2))
    ax.set_title(f"Seller {j}: price ladder and p*")
    ax.legend(loc="upper right")
    fig.tight_layout()
    plt.show()


def plot_threshold_cross_section(M, j):
    qcol = M["bid_q"][:, j]
    pcol = M["bid_p"][:, j]
    bids = [(float(pcol[i]), float(qcol[i])) for i in range(M["I"]) if qcol[i] > 0.0]
    if not bids:
        print(f"Seller {j}: no bids.")
        return
    bids.sort(reverse=True)
    prices = np.array([b[0] for b in bids])
    qtys = np.array([b[1] for b in bids])
    cum = np.cumsum(qtys)
    Qj = float(M["Q_max"][j])
    p_star = 0.0
    for k in range(len(cum)):
        if cum[k] >= Qj:
            p_star = prices[k]
            break
    fig, ax = plt.subplots(figsize=(7, 3.2))
    ax.step(prices, cum, where="post")
    ax.axhline(Qj, linestyle="--", linewidth=1, label=f"Q_j={Qj:g}")
    if p_star > 0:
        ax.axvline(p_star, linestyle=":", linewidth=1)
        ax.text(p_star, 0, f"  p*={p_star:.3g}", va="bottom", ha="left")
    ax.set_xlabel("price")
    ax.set_ylabel("cumulative quantity ≥ price")
    ax.set_title(f"Seller {j}: threshold cross-section")
    ax.legend(loc="lower left")
    plt.tight_layout()
    plt.show()

def plot_shared_buyer_surface_z0z1(M, i, sellers=(0,1), steps=60,
                                   elev=25, azim=-120):
    j0, j1 = sellers
    z0s = np.linspace(0.0, float(M["Q_max"][j0]), steps)
    z1s = np.linspace(0.0, float(M["Q_max"][j1]), steps)
    Z0, Z1 = np.meshgrid(z0s, z1s)
    U = np.zeros_like(Z0)
    q0_old, q1_old = float(M["bid_q"][i, j0]), float(M["bid_q"][i, j1])
    p0_old, p1_old = float(M["bid_p"][i, j0]), float(M["bid_p"][i, j1])
    def w_at(z0, z1): return float(theta_i_prime(i, float(z0+z1), M))
    w_label = r"w = θ′(z₀+z₁)"
    for r, z1 in enumerate(z1s):
        for c, z0 in enumerate(z0s):
            w = w_at(z0, z1)
            M["bid_q"][i, j0] = float(z0); M["bid_q"][i, j1] = float(z1)
            M["bid_p"][i, j0] = w;         M["bid_p"][i, j1] = w
            #U[r, c] = u_i_current(i, M)
            U[r, c] = eval_u_i_two_sellers(M, i, j0, j1, z0=Z0[r,c], z1=Z1[r,c])
    M["bid_q"][i, j0] = q0_old; M["bid_q"][i, j1] = q1_old
    M["bid_p"][i, j0] = p0_old; M["bid_p"][i, j1] = p1_old
    fig = plt.figure(figsize=(7, 5.5))
    ax = fig.add_subplot(111, projection="3d")
    surf = ax.plot_surface(Z0, Z1, U, rstride=1, cstride=1, linewidth=0, alpha=0.9)
    ax.set_xlabel(f"allocation from seller {j0} (z₀)")
    ax.set_ylabel(f"allocation from seller {j1} (z₁)")
    ax.set_zlabel("uᵢ")
    ax.set_title(f"Buyer {i}: utility surface in (z₀, z₁) — {w_label}")
    ax.contour(Z0, Z1, U, zdir='z', offset=U.min(), levels=12, linewidths=0.8, alpha=0.7)
    a_vec, _ = a_row(i, M)
    ax.scatter([a_vec[j0]], [a_vec[j1]], [u_i_current(i, M)],
                s=50, c="k", marker="o", label="current")
    ax.legend(loc="best")
    ax.view_init(elev=elev, azim=azim)
    fig.colorbar(surf, shrink=0.65, aspect=12, pad=0.12, label="uᵢ")
    plt.tight_layout(); plt.show()

def plot_shared_buyer_surface_split(M, i, sellers=(0,1), q_steps=60, a_steps=60):
    j0, j1 = sellers
    qmax = float(M["Q_max"][j0] + M["Q_max"][j1])
    zs   = np.linspace(0.0, max(qmax, 1e-12), q_steps)
    alps = np.linspace(0.0, 1.0, a_steps)
    Z, A = np.meshgrid(zs, alps)
    U    = np.zeros_like(Z)
    # snapshot
    q0_old, q1_old = float(M["bid_q"][i, j0]), float(M["bid_q"][i, j1])
    p0_old, p1_old = float(M["bid_p"][i, j0]), float(M["bid_p"][i, j1])
    def w_at(z): return float(theta_i_prime(i, float(z), M))
    # evaluate u on grid (others held fixed)
    for r in range(a_steps):
        for c in range(q_steps):
            z_tot = float(Z[r, c]); alpha = float(A[r, c])
            z0 = alpha * z_tot
            z1 = (1.0 - alpha) * z_tot
            w  = w_at(z_tot)
            M["bid_p"][i, j0] = w;  M["bid_p"][i, j1] = w
            z0 = alpha * z_tot
            z1 = (1 - alpha) * z_tot
            M["bid_q"][i, j0] = z0; M["bid_q"][i, j1] = z1
            ##U[r, c] = u_i_current(i, M)
            U[r, c] = eval_u_i_two_sellers(M, i, j0, j1, z0=z0, z1=z1)
    # restore
    M["bid_q"][i, j0] = q0_old; M["bid_q"][i, j1] = q1_old
    M["bid_p"][i, j0] = p0_old; M["bid_p"][i, j1] = p1_old
    # plot
    fig = plt.figure(figsize=(6, 5))
    ax = fig.add_subplot(111, projection="3d")
    ax.plot_surface(Z, A, U, rstride=1, cstride=1, linewidth=0, alpha=0.85)
    ax.set_xlabel("total quantity z_total")
    ax.set_ylabel(r"split $\alpha$  (z$_{j0}$ = α·z,  z$_{j1}$ = (1−α)·z)")
    ax.set_zlabel("u_i")
    title = f"Buyer {i}: utility vs total & split (sellers {j0},{j1})"
    title += " — uniform w = θ′(z_total)"
    ax.set_title(title)

    a_vec, z_now = a_row(i, M)
    alpha_now = float(a_vec[j0] / max(z_now, 1e-12)) if z_now > 0 else 0.0
    u_now     = u_i_current(i, M)
    ax.scatter([z_now], [alpha_now], [u_now], s=50, c="k", marker="o", label="current")
    ax.legend(loc="best")
    plt.tight_layout(); plt.show()


def plot_prices_vs_percent(P, E, V=None, T=None, labels=None,
                          title="Marginal value vs % multi-auction buyers",
                          config=None):
    fig, ax = plt.subplots(figsize=(7, 5))
    L, J = E.shape
    if labels is None:
        labels = [f"Seller {j}" for j in range(J)]
    x = 100.0 * P

    for j in range(J):
        ax.plot(x, E[:, j], lw=2, label=f"{labels[j]} – E")
        if V is not None:
            std = np.sqrt(np.maximum(V[:, j], 0.0))
            ax.fill_between(x, E[:, j]-std, E[:, j]+std, alpha=0.18)
        if T is not None:
            ax.plot(x, T[:, j], linestyle=":", lw=2.0, label=f"{labels[j]} – p*")

    ax.set_xlabel("% of buyers bidding in multiple auctions")
    ax.set_ylabel("Price")
    ax.set_title(title)
    ax.grid(True, linestyle=":", alpha=0.6)
    ax.legend(loc="best", fontsize=9)

    if config is not None:
        info = []
        for key in config:
            val = config[key]
            info.append(f"{key}={val}")
        if info:
            ax.text(1.02, 0.05, "\n".join(info), transform=ax.transAxes, ha="left", va="bottom",
                    fontsize=9, bbox=dict(facecolor="white", alpha=0.85, edgecolor="lightgray"))
    fig.tight_layout()
    plt.show()

def plot_utility_surface(M: Dict, i: int, j: int, q_steps: int = 50, p_steps: int = 50):
    """Plot u_i under PSP cost while varying (q,p) at seller j.
    """
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D # noqa: F401 (needed for 3D projection)

    zs = np.linspace(0.0, float(M["Q_max"][j]), q_steps)
    w_max = theta_i_prime(i, 0.0, M)
    ws = np.linspace(0.0, max(w_max, 1e-12), p_steps)
    Z, W = np.meshgrid(zs, ws)
    U = np.zeros_like(Z)

    # snapshot original cell and compute
    q_old = float(M["bid_q"][i, j]); p_old = float(M["bid_p"][i, j])
    for r in range(p_steps):
      for c in range(q_steps):
        M["bid_q"][i, j] = float(Z[r, c])
        M["bid_p"][i, j] = float(W[r, c])
        U[r, c] = u_i_current(i, M)
    M["bid_q"][i, j] = q_old
    M["bid_p"][i, j] = p_old

    print(f"Utility range (buyer {i}, seller {j}): {U.min():.6f} .. {U.max():.6f}")
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_wireframe(Z, W, U, rstride=1, cstride=1)
    ax.set_xlabel('quantity z to seller j')
    ax.set_ylabel('price w to seller j')
    ax.set_zlabel('u_i (PSP)')
    ax.set_title(f'Utility Surface (buyer {i}, seller {j})')
    plt.tight_layout(); plt.show()

# =====================================================
# Engine
# =====================================================

# ------------------------------
# Engine run loop
# ------------------------------

def run(M: Dict, steps: int = 1000, verbose: bool = False, *, idle_event_limit: int | None = None):
    """Run the engine.

    If M["instant_post"] is True, only BUYER_COMPUTE events will be present
    (POST_BID is unused). If M["deterministic_sched"] is True, scheduling uses
    deterministic times (no jitter), improving reproducibility.

    break_on_convergence: stop when no POST_BID has applied for
      idle_event_limit events and there are no pending POST_BIDs.
    idle_event_limit: default = I (set at runtime if None).
    """
    if idle_event_limit is None:
        idle_event_limit = int(M["I"]) if M["I"] else 4

    for it in range(steps):
        item = pop(M)
        if item is None:
            break
        t, _, etype, payload = item
        M["t"] = float(t)
        if etype == BUYER_COMPUTE:
            (i,) = payload
            handle_buyer_compute(M, int(i), verbose=verbose)
            # count toward idle if nothing applied elsewhere
            M["events_since_apply"] = M.get("events_since_apply", 0) + 1
        elif etype == POST_BID:
            i, j, q, p, gen = payload
            handle_post_bid(M, int(i), int(j), float(q), float(p), int(gen), verbose=verbose)
            # events_since_apply reset inside handler on apply
        else:
            raise RuntimeError(f"Unknown event type {etype}")

        # Convergence check: no pending posts and long idle since last apply
        pend = M.get("pending_posts", 0)
        if pend == 0 and M.get("events_since_apply", 0) >= idle_event_limit:
            if verbose:
                print(f"Converged: no price updates for {M['events_since_apply']} events; pending_posts=0")
            break

    return it

# =====================================================
# 1) Sanity (Price-Ladder)
# =====================================================

def seed_bids(M, bids):
    """
    bids: iterable of (i, j, q, p)
    """
    for (i, j, q, p) in bids:
        M["bid_q"][i, j] = float(q)
        M["bid_p"][i, j] = float(p)

def run_sanity_ladder():
    """
    Construction:
      - Two sellers: j=1 (Q=8), ℓ=0 (Q=15).
      - Buyer i (idx 0): bids high on BOTH sellers (q=8 on j & ℓ at price 40).
      - Buyer k (idx 1): bids only on ℓ (q=2 at price 4).
      - Buyer z2 (idx 2): bids only on ℓ (q=6 at very low price 1).
      - Buyer z1 (idx 3): inactive (kept for indexing symmetry).

    Outcomes:
      - Seller j (1): winners {i}; p*_j ≈ 40 (filled by i alone).
      - Seller ℓ (0): winners {i, k, z2}; p*_ℓ ≈ 1 (marginal tier is low).
      - Ladder tuple (ℓ,k,j,i) should satisfy p*_ℓ < p_k < p*_j ≤ p_i.
    """
    from math import isclose
    I=4; J=2
    ell, j = 0, 1     # two sellers
    i, k   = 0, 1    # pick any two distinct buyers

    adj = np.ones((I, J), dtype=bool)
    adj[i, ell] = True
    adj[i, j]   = True
    adj[k, ell] = True
    adj[k, j]   = False

    M = make_market_multi(I=I, J=J, Q_max=[15.0, 8.0], epsilon=2.5, adj=adj, price_tol=5e-3)
    #plot_connectivity(M, title="Market connectivity", show_labels=True)

    # (i=0) high price on both sellers; (k=1) only ℓ; (z2=2) only ℓ; (z1=3) inactive
    seed_bids(M, [
        (0, 1, 8.0, 40.0),  # i on j
        (0, 0, 8.0, 40.0),  # i on ℓ
        (1, 0, 2.0,  4.0),  # k on ℓ
        (2, 0, 6.0,  1.0),  # z2 on ℓ
        #(3, 1, 2.0, 1.2)  # z1 inactive to keep p*_j high; uncomment to test variants
    ])

    # Ladder check
    df = make_ladder_report(M)
    metrics = compute_market_metrics(M)
    rep = market_report_from(metrics)
    print_df(rep)
    """
    plot_buyer_diagnostics(M, i=0, show_jbr=True)
    plot_buyer_diagnostics(M, i=2, show_jbr=True)


    plot_shared_buyer_surface_split(M, 0, sellers=(0,1))
    plot_shared_buyer_surface_z0z1(M, 2, sellers=(0,1))
    plot_seller_price_ladder(M, 0)
    plot_seller_price_ladder(M, 1)
    """

# =====================================================
# 2) Experiment 1 (BFS on Price-Ladder)
# =====================================================
def reset_market_for_new_adj(M: Dict,
                             adj: np.ndarray,
                             *,
                             seed_bids: int | None = None,
                             seed_sched: int | None = None,
                             jitter: float = 0.0) -> None:
    I, J = int(M["I"]), int(M["J"])

    adj = np.asarray(adj, bool)
    M["adj"] = adj

    M["bid_q"].fill(0.0)
    M["bid_p"].fill(0.0)
    if seed_bids is not None:
        randomize_bids(M, seed=seed_bids)
        #fair_bids(M)
    else:
        print("Warning: Initial bids non-deterministic!")

    M["pq"].clear()
    M["seq"] = 0
    M["t"] = 0.0
    M["gen"].fill(0)
    M["pending_posts"] = 0
    M["events_since_apply"] = 0

    # 4) Deterministic scheduling, if desired
    if seed_sched is not None:
        M["rng"] = np.random.default_rng(seed_sched)
    else:
        print("Warning: Non-deterministic scheduling!")
    M["jitter"] = float(jitter)


def run_experiment(I, J, percents, Q_max, epsilon, reserve, steps, base_seed, jitter):
    # Fix primitives once
    Q = np.full(J, float(Q_max)) if np.isscalar(Q_max) else np.asarray(Q_max, float)
    R = np.full(J, float(reserve)) if np.isscalar(reserve) else np.asarray(reserve, float)

    M = make_market_multi(I, J, Q_max=Q, epsilon=epsilon, reserve=R,
                          seed=base_seed, adj=np.ones((I, J), dtype=bool))

    P = np.asarray(percents, float)
    E = np.zeros((len(P), J)); V = np.zeros((len(P), J))
    T = np.zeros((len(P), J))

    seed_bids  = base_seed + 17    # same bids across levels
    seed_sched0 = base_seed + 313  # deterministic schedule per level

    for li, pm in enumerate(P):
        # new adjacency for this level (percent-specific but reproducible)
        rng_adj = np.random.default_rng(base_seed + 1009*li)
        adj = make_membership_adj(I, J, pm, rng=rng_adj)

        # reuse the same market: swap adj + reset state/bids
        reset_market_for_new_adj(M, adj, seed_bids=seed_bids,
                                 seed_sched=seed_sched0 + li, jitter=0.0)

        #M["instant_post"] = True            # apply updates on compute, no POST_BID
        #M["deterministic_sched"] = True     # schedule computes at t0+i, no jitter

        schedule_all_buyers_stable(M, seed_order=42, t0=0.0)
        #schedule_all_buyers(M, t0=0.0)

        it = run(M, steps=2000, verbose=False)

        metrics = compute_market_metrics(M)
        rep = market_report_from(metrics)
        rep["% shared buyers"] = pm
        print_df(rep)
        df = make_ladder_report(M)

        plot_connectivity(M, title="Market connectivity", show_labels=True)
        if M["adj"][6,0] and M["adj"][6,1]:
            plot_buyer_diagnostics(M, i=6, show_jbr=True)
            plot_shared_buyer_surface_split(M, 6, sellers=(0,1))
            plot_shared_buyer_surface_z0z1(M, 6, sellers=(0,1))

        # 1) Global classification (one row per buyer)
        df_bstat = classify_buyers(M)
        n_zero_alloc_pos_bid = int(df_bstat["zero_alloc_pos_bid"].sum())
        n_zero_bid_no_gain   = int(df_bstat["zero_bid_no_gain"].sum())

        # 2) Per-seller loser counts
        losers_per_seller = per_seller_outbid_losers(M)

        rep["losers"] = losers_per_seller  # per seller
        print_df(rep)
        # Add global counts (same value on each seller row for convenience)
        rep["zero_alloc_pos_bid_total"] = n_zero_alloc_pos_bid
        rep["zero_bid_no_gain_total"]   = n_zero_bid_no_gain

        # metrics & reports
        E[li] = rep["E_j"].to_numpy()
        V[li] = rep["V_j"].to_numpy()
        T[li] = rep["p_star_j"].to_numpy()

    return M, P, E, V, T


def experiment1():
    I, J = 8, 2
    percents = [x / 100.0 for x in range(0, 101, 10)]  # 0 → 100
    base_seed=20405008
    Q_max=[60.0, 40.0]
    epsilon=2.5
    jitter=0.0

    M, P, E, V, T = run_experiment(
        I=I,
        J=J,
        percents=percents,
        Q_max=Q_max,
        epsilon=epsilon,
        reserve=[0.0, 0.0],
        steps=1500,
        base_seed=base_seed,
        jitter=jitter
    )
    seeds = record_seeds(
        base_seed=base_seed,
        I=I, J=J, percents=percents,
        verbose=True
    )

    tbl_E = pd.DataFrame({
        f"Seller {j}": [f"{E[li, j]:.3f} ± {np.sqrt(V[li, j]):.3f}" for li in range(len(P))]
        for j in range(J)
    }, index=[f"{int(100*p)}%" for p in P])

    print_df(tbl_E, header="E_j ± √V_j by percent (mean ± std)")

    plot_prices_vs_percent(P, E, V, T,
                           labels=[f"Seller {j}" for j in range(J)],
                           config={"epsilon": epsilon,
                                    "base_seed": base_seed,
                                    "Q_max": Q_max,
                                    "jitter": jitter,
                                    "#buyers": I}
                           )

# -----------------
# Demo (minimal)
# -----------------
if __name__ == "__main__":
    run_sanity_ladder()

    #experiment1()

